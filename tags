!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACCESSBRANCHBROTHER	streemac.h	26;"	d
ACCESSDEPTH	streemac.h	22;"	d
ACCESSFIRSTCHILD	streemac.h	25;"	d
ACCESSHEADPOS	streemac.h	23;"	d
ACCESSSUFFIXLINK	streemac.h	24;"	d
ADDAMOUNT	depthtab.cpp	17;"	d	file:
ADDFACTOR	construct.cpp	71;"	d	file:
ADDOPTION	optdesc.h	45;"	d
ALLOCSPACE	spacedef.h	70;"	d
ALLOCVIAFATAL	space.cpp	51;"	d	file:
ARGS_H	args.h	12;"	d
ARRAYDEF_H	arraydef.h	12;"	d
ASSIGNDEFAULTSHOWDESC	multidef.h	74;"	d
ASSIGNMAXMATCOMPLEMENT	procmaxmat.cpp	127;"	d	file:
ArrayCharacters	arraydef.h	/^typedef ArrayUchar ArrayCharacters;     \/\/ \\Typedef{ArrayCharacters}$/;"	t
ArrayPosition	arraydef.h	/^typedef ArrayUint  ArrayPosition;       \/\/ \\Typedef{ArrayPosition}$/;"	t
ArrayStrings	arraydef.h	/^struct ArrayStrings$/;"	s
BRADDR2NUM	streemac.h	60;"	d
Blockdescription	space.cpp	/^struct Blockdescription$/;"	s	file:
Branchinfo	streetyp.h	/^struct Branchinfo$/;"	s
Bref	streetyp.h	/^DECLAREARRAYSTRUCT(Bref);$/;"	v
Bref	streetyp.h	/^typedef Uint * Bref;    \/\/ \\Typedef{Bref}$/;"	t
Bref	types.h	/^typedef Uint * Bref;    $/;"	t
By_Q	findmumcand.cpp	/^static int  By_Q (const void * A, const void * B)$/;"	f	file:
By_R	findmumcand.cpp	/^static int  By_R (const void * A, const void * B)$/;"	f	file:
CC	Makefile	/^CC = g++$/;"	m
CFLAGS	Makefile	/^CFLAGS = -O3 -g -m64 -fopenmp -D_GLIBCXX_PARALLEL -msse4.2$/;"	m
CHARDEF_H	chardef.h	12;"	d
CHECKADDR	streemac.h	66;"	d
CHECKARGNUM	args.h	28;"	d
CHECKARRAYSPACE	arraydef.h	63;"	d
CHECKARRAYSPACEMULTI	arraydef.h	81;"	d
CHECKIFLOCATIONISVALID	findmaxmat.cpp	131;"	d	file:
CHECKSTEP	construct.cpp	696;"	d	file:
CHECKSTEP	construct.cpp	811;"	d	file:
CHECKSTEP	findmaxmat.cpp	38;"	d	file:
CHECKTEXTLEN	construct.cpp	26;"	d	file:
CHILD	sparseSA.hpp	/^  vector<int> CHILD; \/\/child table$/;"	m	struct:sparseSA
CLEARBITTAB	intbits.h	74;"	d
COMPLETELARGEFIRST	construct.cpp	692;"	d	file:
COMPLETELARGEFIRST	construct.cpp	808;"	d	file:
COMPLETELARGESECOND	construct.cpp	693;"	d	file:
COMPLETELARGESECOND	construct.cpp	809;"	d	file:
CONSTRUCTSTREE	streemac.h	33;"	d
COPYMULTISEQ	multiseq.cpp	51;"	d	file:
CREATEMEMORYMAP	spacedef.h	96;"	d
CREATEMEMORYMAPFORFILEDESC	spacedef.h	99;"	d
CXXFLAGS	Makefile	/^CXXFLAGS = -O3 -m64 -fopenmp -D_GLIBCXX_PARALLEL -msse4.2 $/;"	m
DECLAREARRAYSTRUCT	arraydef.h	41;"	d
DECLAREEXTRA	construct.cpp	680;"	d	file:
DECLAREEXTRA	construct.cpp	807;"	d	file:
DECLAREEXTRA	findmaxmat.cpp	26;"	d	file:
DEFAULTCHUNK	maxmatopt.cpp	39;"	d	file:
DEFAULTMINUNIQUEMATCHLEN	maxmatopt.cpp	33;"	d	file:
DELETEMEMORYMAP	spacedef.h	102;"	d
DESCRIPTIONLENGTH	multidef.h	66;"	d
DESCRIPTIONPTR	multidef.h	63;"	d
DESCRIPTIONSTARTDESC	multidef.h	60;"	d
DFSstate	streetyp.h	/^struct DFSstate$/;"	s
DISTRIBUTE_H	distribute.h	19;"	d
DIV2	types.h	40;"	d
DIVBYSMALLINTS	streehuge.h	33;"	d
DIVWORDSIZE	intbits.h	47;"	d
DYNAMICSTRDUP	spacedef.h	93;"	d
ERROR0	errordef.h	60;"	d
ERROR1	errordef.h	63;"	d
ERROR2	errordef.h	66;"	d
ERROR3	errordef.h	69;"	d
ERROR4	errordef.h	72;"	d
ERROR5	errordef.h	75;"	d
ERRORDEF_H	errordef.h	12;"	d
EXCEPTFIRSTBIT	intbits.h	41;"	d
EXCEPTFIRSTTHREEBITS	intbits.h	45;"	d
EXCEPTFIRSTTWOBITS	intbits.h	43;"	d
FASTASEPARATOR	multidef.h	52;"	d
FINALPROGRESS	construct.cpp	714;"	d	file:
FINALPROGRESS	construct.cpp	812;"	d	file:
FIRSTBIT	intbits.h	29;"	d
FIRSTTWOBITS	intbits.h	39;"	d
FOLLOWSUFFIXLINK	streeacc.h	154;"	d
FREEARRAY	arraydef.h	116;"	d
FREESPACE	spacedef.h	80;"	d
Filter_Matches	findmumcand.cpp	/^static void  Filter_Matches (Match_t * A, int & N)$/;"	f	file:
Findmatchfunction	procmaxmat.cpp	/^typedef Sint (*Findmatchfunction)(Uchar *,$/;"	t	file:
GENERROR	errordef.h	45;"	d
GETBOTH	streeacc.h	39;"	d
GETBRANCHINDEX	streehuge.h	56;"	d
GETBROTHER	streehuge.h	63;"	d
GETCHAINEND	streehuge.h	85;"	d
GETCHILD	streehuge.h	62;"	d
GETDEPTH	streehuge.h	65;"	d
GETDEPTHAFTERHEADPOS	streeacc.h	105;"	d
GETDISTANCE	streehuge.h	64;"	d
GETHEADPOS	streehuge.h	66;"	d
GETHEADPOSAFTERDEPTH	streeacc.h	120;"	d
GETLEAFINDEX	streehuge.h	55;"	d
GETNEXTFREEINARRAY	arraydef.h	98;"	d
GETONLYDEPTH	streeacc.h	87;"	d
GETONLYHEADPOS	streeacc.h	69;"	d
GETSUFFIXLINK	streehuge.h	67;"	d
Good	arraydef.h	/^   unsigned int  Good : 1;$/;"	m	struct:Match_t
HIGHESTVISIBLE	visible.h	34;"	d
I	qsufsort.c	/^static int *I,                  \/* group array, ultimately suffix array.*\/$/;"	v	file:
INCLUDE	Makefile	/^INCLUDE = -I\/soft\/papi-5.0.1\/include$/;"	m
INITARRAY	arraydef.h	52;"	d
INITBITTAB	intbits.h	59;"	d
INTBITS_H	intbits.h	12;"	d
INTWORDSIZE	intbits.h	27;"	d
INVISIBLE	visible.h	40;"	d
INVISIBLECHAR	visible.h	54;"	d
ISA	sparseSA.hpp	/^  vector<int> ISA;  \/\/ Inverse suffix array.$/;"	m	struct:sparseSA
ISBITSET	intbits.h	31;"	d
ISBRANCHUSED	streedbg.cpp	21;"	d	file:
ISIBITSET	intbits.h	103;"	d
ISLARGE	streehuge.h	50;"	d
ISLEAF	streehuge.h	49;"	d
ISLEAFUSED	streedbg.cpp	18;"	d	file:
ISNOTSPECIAL	chardef.h	26;"	d
ISSET	optdesc.h	55;"	d
ISSPECIAL	chardef.h	25;"	d
ITHBIT	intbits.h	33;"	d
K	mummer.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
K	mummer.mod.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
K	mummer.pomp.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
K	mummer.s	/^K:$/;"	l
K	sparseSA.hpp	/^  long K; \/\/ suffix sampling, K = 1 every suffix, K = 2 every other suffix, K = 3, every 3rd sffix$/;"	m	struct:sparseSA
KEY	qsufsort.c	21;"	d	file:
Kvalues	sparseSA.cpp	/^  vector<long> Kvalues; \/\/ Values of K this thread should process.$/;"	m	struct:thread_data	file:
Kvalues	sparseSA.mod.cpp	/^  vector<long> Kvalues; \/\/ Values of K this thread should process.$/;"	m	struct:thread_data	file:
Kvalues	sparseSA.pomp.cpp	/^  vector<long> Kvalues; \/\/ Values of K this thread should process.$/;"	m	struct:thread_data	file:
LARGEINTS	streehuge.h	31;"	d
LARGESTCHARINDEX	streehuge.h	96;"	d
LARGESTCHARINDEX	streehuge.h	98;"	d
LCP	sparseSA.hpp	/^  vec_uchar LCP; \/\/ Simulates a vector<int> LCP.$/;"	m	struct:sparseSA
LCPCHILD	sparseSA.cpp	20;"	d	file:
LCPCHILD	sparseSA.mod.cpp	22;"	d	file:
LCPCHILD	sparseSA.pomp.cpp	17;"	d	file:
LDFLAGS	Makefile	/^LDFLAGS = -Wl,-rpath, -L\/soft\/papi-5.0.1\/lib -L\/soft\/cuda-5.0\/extras\/CUPTI\/lib64 -L\/soft\/cuda-5.0\/lib64 $/;"	m
LEADLEVEL	streeacc.h	198;"	d
LEAFADDR2NUM	streemac.h	61;"	d
LEAFBIT	streehuge.h	35;"	d
LEAFBROTHERVAL	streehuge.h	82;"	d
LEASTSHOWPROGRESS	construct.cpp	677;"	d	file:
LEASTSHOWPROGRESS	findmaxmat.cpp	23;"	d	file:
LIBS	Makefile	/^LIBS = -lstdc++ -lpapi -lpthread$/;"	m
LOGWORDSIZE	types.h	35;"	d
LOWESTVISIBLE	visible.h	28;"	d
Leafinfo	streetyp.h	/^typedef Reference Leafinfo;  \/\/ \\Typedef{Leafinfo}$/;"	t
Len	arraydef.h	/^   long int Len = -1;$/;"	m	struct:Match_t
ListType	types.h	/^struct ListType$/;"	s
Location	streetyp.h	/^struct Location$/;"	s
Lref	streetyp.h	/^typedef Uint * Lref;    \/\/ \\Typedef{Lref}$/;"	t
Lref	types.h	/^typedef Uint * Lref;  $/;"	t
M	sparseSA.hpp	/^  vector<item_t> M;$/;"	m	struct:vec_uchar
MAKEBRANCHADDR	streehuge.h	86;"	d
MAKELARGE	streehuge.h	52;"	d
MAKELARGELEAF	streehuge.h	53;"	d
MAKELEAF	streehuge.h	51;"	d
MAM	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MAM	mummer.mod.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MAM	mummer.pomp.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MAM	sparseSA.hpp	/^  void MAM(string &P, int chunk, int chunks, vector<match_t> &matches, int min_len, long& memCount, bool print) { $/;"	f	struct:sparseSA
MAX	minmax.h	22;"	d
MAXDISTANCE	streehuge.h	39;"	d
MAXERRORMSG	seterror.cpp	27;"	d	file:
MAXINDEX	streehuge.h	38;"	d
MAXMAPPEDFILES	mapfile.cpp	25;"	d	file:
MAXMATDEF_H	maxmatdef.h	12;"	d
MAXNUMOFQUERYFILES	maxmatdef.h	52;"	d
MAXTEXTLEN	streehuge.h	60;"	d
MED3	qsufsort.c	23;"	d	file:
MEM	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MEM	mummer.mod.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MEM	mummer.pomp.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MEM	sparseSA.cpp	/^void sparseSA::MEM(string &P, vector<match_t> &matches, int min_len, bool print, long& currentCount, int num_threads) {$/;"	f	class:sparseSA
MEM	sparseSA.mod.cpp	/^void sparseSA::MEM(string &P, vector<match_t> &matches, int min_len, bool print, long& currentCount, int num_threads) {$/;"	f	class:sparseSA
MEM	sparseSA.pomp.cpp	/^void sparseSA::MEM(string &P, vector<match_t> &matches, int min_len, bool print, long& currentCount, int num_threads) {$/;"	f	class:sparseSA
MEMthread	sparseSA.cpp	/^void *MEMthread(void *arg) {$/;"	f
MEMthread	sparseSA.mod.cpp	/^void *MEMthread(void *arg) {$/;"	f
MEMthread	sparseSA.pomp.cpp	/^void *MEMthread(void *arg) {$/;"	f
MIN	minmax.h	26;"	d
MINEXTRA	construct.cpp	72;"	d	file:
MINMAX_H	minmax.h	12;"	d
MMREPLACEMENTCHARQUERY	maxmatdef.h	46;"	d
MMREPLACEMENTCHARSUBJECT	maxmatdef.h	45;"	d
MMcallinfo	maxmatdef.h	/^struct MMcallinfo$/;"	s
MODWORDSIZE	intbits.h	49;"	d
MULTBYSMALLINTS	streehuge.h	32;"	d
MULTIDEF_H	multidef.h	12;"	d
MULWORDSIZE	intbits.h	51;"	d
MUM	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MUM	mummer.mod.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MUM	mummer.pomp.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MUM	sparseSA.cpp	/^void sparseSA::MUM(string &P, vector<match_t> &unique, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
MUM	sparseSA.mod.cpp	/^void sparseSA::MUM(string &P, vector<match_t> &unique, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
MUM	sparseSA.pomp.cpp	/^void sparseSA::MUM(string &P, vector<match_t> &unique, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
MUMCAND_H	mumcand.h	12;"	d
MUMParallel	sparseSA.cpp	/^void sparseSA::MUMParallel(string &P, int chunks, vector<match_t> &unique, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
MUMParallel	sparseSA.mod.cpp	/^void sparseSA::MUMParallel(string &P, int chunks, vector<match_t> &unique, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
MUMParallel	sparseSA.pomp.cpp	/^void sparseSA::MUMParallel(string &P, int chunks, vector<match_t> &unique, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
MUMcandidate	mumcand.h	/^DECLAREARRAYSTRUCT(MUMcandidate);$/;"	v
MUMcandidate	mumcand.h	/^struct MUMcandidate$/;"	s
Match_t	arraydef.h	/^struct  Match_t$/;"	s
Matchprocessinfo	maxmatdef.h	/^struct Matchprocessinfo$/;"	s
Maxmatchinfo	findmaxmat.cpp	/^struct Maxmatchinfo$/;"	s	file:
Multiseq	multidef.h	/^struct Multiseq$/;"	s
N	sparseSA.hpp	/^  long N; \/\/!< Length of the sequence.$/;"	m	struct:sparseSA
NEWLINE	multiseq.cpp	39;"	d	file:
NEXTNODE	streeacc.h	136;"	d
NILBIT	streehuge.h	37;"	d
NILPTR	streehuge.h	58;"	d
NKm1	sparseSA.hpp	/^  long NKm1; \/\/ N\/K - 1$/;"	m	struct:sparseSA
NOTSUPPOSED	errordef.h	110;"	d
NOTSUPPOSEDTOBENULL	errordef.h	120;"	d
NUMOFCALLS	construct.cpp	678;"	d	file:
NUMOFCALLS	findmaxmat.cpp	24;"	d	file:
NUMOFOPTIONS	maxmatopt.cpp	/^  NUMOFOPTIONS$/;"	e	enum:__anon1	file:
Nodeinfo	findmaxmat.cpp	/^DECLAREARRAYSTRUCT(Nodeinfo);$/;"	v
Nodeinfo	findmaxmat.cpp	/^struct Nodeinfo$/;"	s	file:
OPTCHUNKS	maxmatopt.cpp	/^  OPTCHUNKS,$/;"	e	enum:__anon1	file:
OPTCOMPUTEBOTHDIRECTIONS	maxmatopt.cpp	/^  OPTCOMPUTEBOTHDIRECTIONS,$/;"	e	enum:__anon1	file:
OPTDESC_H	optdesc.h	12;"	d
OPTFOURCOLUMN	maxmatopt.cpp	/^  OPTFOURCOLUMN,$/;"	e	enum:__anon1	file:
OPTH	maxmatopt.cpp	/^  OPTH,$/;"	e	enum:__anon1	file:
OPTHELP	maxmatopt.cpp	/^  OPTHELP,$/;"	e	enum:__anon1	file:
OPTION	optdesc.h	32;"	d
OPTIONEXCLUDE	optdesc.h	128;"	d
OPTIONIMPLY	optdesc.h	75;"	d
OPTIONIMPLYEITHER2	optdesc.h	83;"	d
OPTIONIMPLYEITHER3	optdesc.h	94;"	d
OPTIONIMPLYEITHER4	optdesc.h	108;"	d
OPTIONMANDATORY	optdesc.h	62;"	d
OPTLEASTLENGTH	maxmatopt.cpp	/^  OPTLEASTLENGTH,$/;"	e	enum:__anon1	file:
OPTMATCHNUCLEOTIDESONLY	maxmatopt.cpp	/^  OPTMATCHNUCLEOTIDESONLY,$/;"	e	enum:__anon1	file:
OPTMAXMATCH	maxmatopt.cpp	/^  OPTMAXMATCH,$/;"	e	enum:__anon1	file:
OPTMUM	maxmatopt.cpp	/^  OPTMUM = 0,$/;"	e	enum:__anon1	file:
OPTMUMCAND	maxmatopt.cpp	/^  OPTMUMCAND,$/;"	e	enum:__anon1	file:
OPTMUMREF	maxmatopt.cpp	/^  OPTMUMREF,$/;"	e	enum:__anon1	file:
OPTONLYREVERSECOMPLEMENT	maxmatopt.cpp	/^  OPTONLYREVERSECOMPLEMENT,$/;"	e	enum:__anon1	file:
OPTPREFIXLENGTH	maxmatopt.cpp	/^  OPTPREFIXLENGTH,$/;"	e	enum:__anon1	file:
OPTSHOWREVERSEPOSITIONS	maxmatopt.cpp	/^  OPTSHOWREVERSEPOSITIONS,$/;"	e	enum:__anon1	file:
OPTSHOWSEQUENCELENGTHS	maxmatopt.cpp	/^  OPTSHOWSEQUENCELENGTHS,$/;"	e	enum:__anon1	file:
OPTSHOWSTRING	maxmatopt.cpp	/^  OPTSHOWSTRING,$/;"	e	enum:__anon1	file:
OptionDescription	optdesc.h	/^struct OptionDescription$/;"	s
Optionnumber	maxmatopt.cpp	/^} Optionnumber;$/;"	t	typeref:enum:__anon1	file:
P	sparseSA.cpp	/^  string *P; \/\/ Query string.$/;"	m	struct:thread_data	file:
P	sparseSA.mod.cpp	/^  string *P; \/\/ Query string.$/;"	m	struct:thread_data	file:
P	sparseSA.pomp.cpp	/^  string *P; \/\/ Query string.$/;"	m	struct:thread_data	file:
PARSEFLOATARG	args.h	53;"	d
PARSEINTARG	args.h	40;"	d
POMP2_Get_num_regions	pompregions.c	/^size_t POMP2_Get_num_regions()$/;"	f
POMP2_Get_opari2_version	pompregions.c	/^const char* POMP2_Get_opari2_version()$/;"	f
POMP2_Get_required_pomp2_library_version_age	pompregions.c	/^int POMP2_Get_required_pomp2_library_version_age()$/;"	f
POMP2_Get_required_pomp2_library_version_current	pompregions.c	/^int POMP2_Get_required_pomp2_library_version_current()$/;"	f
POMP2_Get_required_pomp2_library_version_revision	pompregions.c	/^int POMP2_Get_required_pomp2_library_version_revision()$/;"	f
POMP2_Init_regions	pompregions.c	/^void POMP2_Init_regions()$/;"	f
PROCESSALL	streedbg.cpp	23;"	d	file:
PROCESSBRANCH1	dfs.cpp	135;"	d	file:
PROCESSBRANCH1	dfs.cpp	137;"	d	file:
PROCESSBRANCH1	dfs.cpp	59;"	d	file:
PROCESSBRANCH2	dfs.cpp	136;"	d	file:
PROCESSBRANCH2	dfs.cpp	138;"	d	file:
PROCESSBRANCH2	dfs.cpp	60;"	d	file:
PROCESSHEAD	construct.cpp	694;"	d	file:
PROCESSHEAD	construct.cpp	810;"	d	file:
PROCESSREALMUMS	procmaxmat.cpp	107;"	d	file:
PROTODEF_H	protodef.h	10;"	d
PairUint	arraydef.h	/^DECLAREARRAYSTRUCT(PairUint);$/;"	v
PairUint	types.h	/^struct PairUint$/;"	s
Papi	PapiCounter.h	/^    Papi() {setup_=false; debug_=false; counting_=false;};$/;"	f	class:Papi
Papi	PapiCounter.h	/^    Papi(Papi const &) {};$/;"	f	class:Papi
Papi	PapiCounter.h	/^class Papi{$/;"	c
PapiCounter	PapiCounter.h	/^PapiCounter::PapiCounter(){$/;"	f	class:PapiCounter
PapiCounter	PapiCounter.h	/^class PapiCounter{$/;"	c
PapiCounterList	PapiCounter.h	/^    PapiCounterList() {};$/;"	f	class:PapiCounterList
PapiCounterList	PapiCounter.h	/^class PapiCounterList{$/;"	c
Pathinfo	streetyp.h	/^DECLAREARRAYSTRUCT(Pathinfo);$/;"	v
Pathinfo	streetyp.h	/^struct Pathinfo$/;"	s
Process_Matches	findmumcand.cpp	/^static void  Process_Matches (Match_t * A, int N) \/\/  Process matches  A [1 .. N].$/;"	f	file:
Processmatchfunction	maxmatdef.h	/^typedef Sint (*Processmatchfunction)$/;"	t
Q	arraydef.h	/^   long int  R, Q; $/;"	m	struct:Match_t
Qsortcomparefunction	types.h	/^typedef int (*Qsortcomparefunction)(const void *,const void *);$/;"	t
R	arraydef.h	/^   long int  R, Q; $/;"	m	struct:Match_t
R	sparseSA.hpp	/^  string &R; \/\/!< Reference to sequence data.$/;"	m	struct:sparseSA
RECALLBRANCHADDRESS	streeacc.h	186;"	d
RECALLLEAFADDRESS	streeacc.h	184;"	d
RECALLNEWLEAFADDRESS	streeacc.h	182;"	d
RECALLSUCC	streeacc.h	174;"	d
ROOT	streemac.h	45;"	d
ROOTLOCATION	streemac.h	52;"	d
Reference	streetyp.h	/^struct Reference$/;"	s
SA	sparseSA.hpp	/^  vector<unsigned int> SA;  \/\/ Suffix array.$/;"	m	struct:sparseSA
SECONDBIT	intbits.h	35;"	d
SEPARATOR	chardef.h	22;"	d
SETBRANCHNODEOFFSET	streehuge.h	87;"	d
SETBRANCHUSED	streedbg.cpp	20;"	d	file:
SETBROTHER	streehuge.h	69;"	d
SETCHILD	streehuge.h	68;"	d
SETCURRENT	dfs.cpp	15;"	d	file:
SETDEPTHHEADPOS	streehuge.h	73;"	d
SETDISTANCE	streehuge.h	71;"	d
SETIBIT	intbits.h	89;"	d
SETLEAFBROTHER	streehuge.h	83;"	d
SETLEAFUSED	streedbg.cpp	17;"	d	file:
SETMAXBRANCHDEPTH	streeacc.h	191;"	d
SETNEWCHILD	streehuge.h	76;"	d
SETNEWCHILDBROTHER	streehuge.h	77;"	d
SETNILBIT	streeacc.h	189;"	d
SETSUFFIXLINK	streehuge.h	80;"	d
SETVAL	streeacc.h	15;"	d
SHOWBOOL	types.h	33;"	d
SHOWCHAR	visible.h	76;"	d
SHOWCHARFP	visible.h	62;"	d
SHOWINDEX	streeacc.h	201;"	d
SHOWREF	streedbg.cpp	480;"	d	file:
SHOWVAL	streeacc.h	14;"	d
SIMPLESTANDARDMESSAGE	errordef.h	101;"	d
SMALLBIT	streehuge.h	36;"	d
SMALLINTS	streehuge.h	30;"	d
SPACEDEF_H	spacedef.h	12;"	d
SRC	Makefile	/^SRC = mummer.cpp qsufsort.c sparseSA.cpp fasta.cpp$/;"	m
STANDARDMESSAGE	errordef.h	97;"	d
STARTFACTOR	construct.cpp	68;"	d	file:
STOREINARRAY	arraydef.h	108;"	d
STORESTARTDESC	maxmatinp.cpp	37;"	d	file:
STORESTARTDESC	multiseq.cpp	57;"	d	file:
STREEACC_H	streeacc.h	10;"	d
STREEDEF_H	streedef.h	10;"	d
STREEHUGE_H	streehuge.h	16;"	d
STREEMAC_H	streemac.h	10;"	d
STREETYP_H	streetyp.h	10;"	d
SWAP	qsufsort.c	22;"	d	file:
SYMBOL	symboldef.h	/^typedef Uchar SYMBOL;$/;"	t
SYMBOL	symboldef.h	/^typedef Uint SYMBOL;$/;"	t
SYMBOL	symboldef.h	/^typedef Ushort SYMBOL;$/;"	t
SYMBOLBYTES	symboldef.h	13;"	d
SYMBOLDEF_H	symboldef.h	10;"	d
Safe_malloc	distribute.cpp	/^void *  Safe_malloc  (size_t Len)$/;"	f
Safe_realloc	distribute.cpp	/^void *  Safe_realloc  (void * Q, size_t Len)$/;"	f
Seqinfo	multidef.h	/^struct Seqinfo$/;"	s
Showdescinfo	multidef.h	/^struct Showdescinfo$/;"	s
Simpleloc	streetyp.h	/^DECLAREARRAYSTRUCT(Simpleloc);$/;"	v
Simpleloc	streetyp.h	/^struct Simpleloc$/;"	s
Sint	arraydef.h	/^DECLAREARRAYSTRUCT(Sint);$/;"	v
Sint	types.h	/^typedef signed long Sint;$/;"	t
Stringtype	types.h	/^typedef ListType Stringtype;$/;"	t
Suffixes	maxmatdef.h	/^typedef vector<suffix> Suffixes;$/;"	t
Suffixtree	streetyp.h	/^struct Suffixtree$/;"	s
THIRDBIT	intbits.h	37;"	d
TYPES_H	types.h	20;"	d
Table	maxmatdef.h	/^typedef map<Uint, Suffixes > Table;$/;"	t
Tentative	arraydef.h	/^   unsigned int  Tentative : 1;$/;"	m	struct:Match_t
ThreeUint	arraydef.h	/^DECLAREARRAYSTRUCT(ThreeUint);$/;"	v
ThreeUint	types.h	/^struct ThreeUint$/;"	s
UNDEFCHAR	chardef.h	24;"	d
UNDEFFILESEP	multidef.h	85;"	d
UNDEFINEDREFERENCE	streehuge.h	59;"	d
UNDEFNUMOFDBSEQ	multiseq.cpp	45;"	d	file:
UNSETIBIT	intbits.h	96;"	d
USAGEOUT	errordef.h	86;"	d
Uchar	types.h	/^typedef unsigned char Uchar;$/;"	t
Uint	arraydef.h	/^DECLAREARRAYSTRUCT(Uint);$/;"	v
Uint	types.h	/^typedef unsigned long Uint;$/;"	t
UintConst	types.h	/^typedef const unsigned long UintConst;$/;"	t
UniqueMumQ	findmumcand.cpp	/^static void UniqueMumQ (Match_t * A, int N)$/;"	f	file:
UniqueMumR	findmumcand.cpp	/^static void UniqueMumR (Match_t * A, int N)$/;"	f	file:
Ushort	arraydef.h	/^DECLAREARRAYSTRUCT(Ushort);$/;"	v
Ushort	types.h	/^typedef unsigned short Ushort;$/;"	t
V	qsufsort.c	/^   *V,                          \/* inverse array, ultimately inverse of I.*\/$/;"	v	file:
VALIDINIT	construct.cpp	24;"	d	file:
VISIBLECHAR	visible.h	48;"	d
VISIBLE_H	visible.h	13;"	d
WILDCARD	chardef.h	23;"	d
_4column	mummer.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
_4column	mummer.mod.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
_4column	mummer.pomp.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
_4column	mummer.s	/^_4column:$/;"	l
_4column	sparseSA.hpp	/^  bool _4column; \/\/ Use 4 column output format.$/;"	m	struct:sparseSA
_GLOBAL__sub_I__Z18reverse_complementRSsb	fasta.s	/^_GLOBAL__sub_I__Z18reverse_complementRSsb:$/;"	l
_GLOBAL__sub_I_cout_mutex	sparseSA.s	/^_GLOBAL__sub_I_cout_mutex:$/;"	l
_GLOBAL__sub_I_min_len	mummer.s	/^_GLOBAL__sub_I_min_len:$/;"	l
_POMP	fasta.mod.cpp	2;"	d	file:
_POMP	fasta.mod.cpp	4;"	d	file:
_POMP	mummer.mod.cpp	2;"	d	file:
_POMP	mummer.mod.cpp	4;"	d	file:
_POMP	sparseSA.mod.cpp	2;"	d	file:
_POMP	sparseSA.mod.cpp	4;"	d	file:
_Z10load_fastaSsRSsRSt6vectorISsSaISsEERS0_IlSaIlEE	fasta.s	/^_Z10load_fastaSsRSsRSt6vectorISsSaISsEERS0_IlSaIlEE:$/;"	l
_Z12query_threadPv	mummer.s	/^_Z12query_threadPv:$/;"	l
_Z18reverse_complementRSsb	fasta.s	/^_Z18reverse_complementRSsb:$/;"	l
_Z4trimRSsRlS0_	fasta.s	/^_Z4trimRSsRlS0_:$/;"	l
_Z5usageSs	mummer.s	/^_Z5usageSs:$/;"	l
_Z9MEMthreadPv	sparseSA.s	/^_Z9MEMthreadPv:$/;"	l
_ZN14__gnu_parallel10_LoserTreeILb0E7match_t6by_refE13__init_winnerEj	sparseSA.s	/^_ZN14__gnu_parallel10_LoserTreeILb0E7match_t6by_refE13__init_winnerEj:$/;"	l
_ZN14__gnu_parallel10_LoserTreeILb0EN9vec_uchar6item_tESt4lessIS2_EE13__init_winnerEj	sparseSA.s	/^_ZN14__gnu_parallel10_LoserTreeILb0EN9vec_uchar6item_tESt4lessIS2_EE13__init_winnerEj:$/;"	l
_ZN14__gnu_parallel18multiseq_partitionIN9__gnu_cxx17__normal_iteratorIPSt4pairIP7match_tS5_ESt6vectorIS6_SaIS6_EEEElNS2_IPS5_S8_IS5_SaIS5_EEEE6by_refEEvT_SH_T0_T1_T2_	sparseSA.s	/^_ZN14__gnu_parallel18multiseq_partitionIN9__gnu_cxx17__normal_iteratorIPSt4pairIP7match_tS5_ESt6vectorIS6_SaIS6_EEEElNS2_IPS5_S8_IS5_SaIS5_EEEE6by_refEEvT_SH_T0_T1_T2_:$/;"	l
_ZN14__gnu_parallel18multiseq_partitionIN9__gnu_cxx17__normal_iteratorIPSt4pairIPN9vec_uchar6item_tES6_ESt6vectorIS7_SaIS7_EEEElNS2_IPS6_S9_IS6_SaIS6_EEEESt4lessIS5_EEEvT_SJ_T0_T1_T2_	sparseSA.s	/^_ZN14__gnu_parallel18multiseq_partitionIN9__gnu_cxx17__normal_iteratorIPSt4pairIPN9vec_uchar6item_tES6_ESt6vectorIS7_SaIS7_EEEElNS2_IPS6_S9_IS6_SaIS6_EEEESt4lessIS5_EEEvT_SJ_T0_T1_T2_:$/;"	l
_ZN14__gnu_parallel18parallel_sort_mwmsILb0ELb1EN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS3_SaIS3_EEEE6by_refEEvT1_SA_T2_t	sparseSA.s	/^_ZN14__gnu_parallel18parallel_sort_mwmsILb0ELb1EN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS3_SaIS3_EEEE6by_refEEvT1_SA_T2_t:$/;"	l
_ZN14__gnu_parallel18parallel_sort_mwmsILb0ELb1EN9__gnu_cxx17__normal_iteratorIPN9vec_uchar6item_tESt6vectorIS4_SaIS4_EEEESt4lessIS4_EEEvT1_SC_T2_t	sparseSA.s	/^_ZN14__gnu_parallel18parallel_sort_mwmsILb0ELb1EN9__gnu_cxx17__normal_iteratorIPN9vec_uchar6item_tESt6vectorIS4_SaIS4_EEEESt4lessIS4_EEEvT1_SC_T2_t:$/;"	l
_ZN14__gnu_parallel21parallel_sort_mwms_puILb0ELb1EN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS3_SaIS3_EEEE6by_refEEvPNS_17_PMWMSSortingDataIT1_EERT2_	sparseSA.s	/^_ZN14__gnu_parallel21parallel_sort_mwms_puILb0ELb1EN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS3_SaIS3_EEEE6by_refEEvPNS_17_PMWMSSortingDataIT1_EERT2_:$/;"	l
_ZN14__gnu_parallel21parallel_sort_mwms_puILb0ELb1EN9__gnu_cxx17__normal_iteratorIPN9vec_uchar6item_tESt6vectorIS4_SaIS4_EEEESt4lessIS4_EEEvPNS_17_PMWMSSortingDataIT1_EERT2_	sparseSA.s	/^_ZN14__gnu_parallel21parallel_sort_mwms_puILb0ELb1EN9__gnu_cxx17__normal_iteratorIPN9vec_uchar6item_tESt6vectorIS4_SaIS4_EEEESt4lessIS4_EEEvPNS_17_PMWMSSortingDataIT1_EERT2_:$/;"	l
_ZN14__gnu_parallel24multiway_merge_3_variantINS_16_GuardedIteratorEN9__gnu_cxx17__normal_iteratorIPSt4pairIP7match_tS6_ESt6vectorIS7_SaIS7_EEEENS3_IS6_S9_IS5_SaIS5_EEEEl6by_refEET1_T0_SI_SH_T2_T3_	sparseSA.s	/^_ZN14__gnu_parallel24multiway_merge_3_variantINS_16_GuardedIteratorEN9__gnu_cxx17__normal_iteratorIPSt4pairIP7match_tS6_ESt6vectorIS7_SaIS7_EEEENS3_IS6_S9_IS5_SaIS5_EEEEl6by_refEET1_T0_SI_SH_T2_T3_:$/;"	l
_ZN14__gnu_parallel24multiway_merge_3_variantINS_16_GuardedIteratorEN9__gnu_cxx17__normal_iteratorIPSt4pairIPN9vec_uchar6item_tES7_ESt6vectorIS8_SaIS8_EEEENS3_IS7_SA_IS6_SaIS6_EEEElSt4lessIS6_EEET1_T0_SK_SJ_T2_T3_	sparseSA.s	/^_ZN14__gnu_parallel24multiway_merge_3_variantINS_16_GuardedIteratorEN9__gnu_cxx17__normal_iteratorIPSt4pairIPN9vec_uchar6item_tES7_ESt6vectorIS8_SaIS8_EEEENS3_IS7_SA_IS6_SaIS6_EEEElSt4lessIS6_EEET1_T0_SK_SJ_T2_T3_:$/;"	l
_ZN14__gnu_parallel24multiway_merge_4_variantINS_16_GuardedIteratorEN9__gnu_cxx17__normal_iteratorIPSt4pairIP7match_tS6_ESt6vectorIS7_SaIS7_EEEENS3_IS6_S9_IS5_SaIS5_EEEEl6by_refEET1_T0_SI_SH_T2_T3_	sparseSA.s	/^_ZN14__gnu_parallel24multiway_merge_4_variantINS_16_GuardedIteratorEN9__gnu_cxx17__normal_iteratorIPSt4pairIP7match_tS6_ESt6vectorIS7_SaIS7_EEEENS3_IS6_S9_IS5_SaIS5_EEEEl6by_refEET1_T0_SI_SH_T2_T3_:$/;"	l
_ZN14__gnu_parallel24multiway_merge_4_variantINS_16_GuardedIteratorEN9__gnu_cxx17__normal_iteratorIPSt4pairIPN9vec_uchar6item_tES7_ESt6vectorIS8_SaIS8_EEEENS3_IS7_SA_IS6_SaIS6_EEEElSt4lessIS6_EEET1_T0_SK_SJ_T2_T3_	sparseSA.s	/^_ZN14__gnu_parallel24multiway_merge_4_variantINS_16_GuardedIteratorEN9__gnu_cxx17__normal_iteratorIPSt4pairIPN9vec_uchar6item_tES7_ESt6vectorIS8_SaIS8_EEEENS3_IS7_SA_IS6_SaIS6_EEEElSt4lessIS6_EEET1_T0_SK_SJ_T2_T3_:$/;"	l
_ZN14__gnu_parallel25multiway_merge_loser_treeINS_10_LoserTreeILb0E7match_t6by_refEEN9__gnu_cxx17__normal_iteratorIPSt4pairIPS2_S8_ESt6vectorIS9_SaIS9_EEEENS6_IS8_SB_IS2_SaIS2_EEEElS3_EET1_T0_SJ_SI_T2_T3_	sparseSA.s	/^_ZN14__gnu_parallel25multiway_merge_loser_treeINS_10_LoserTreeILb0E7match_t6by_refEEN9__gnu_cxx17__normal_iteratorIPSt4pairIPS2_S8_ESt6vectorIS9_SaIS9_EEEENS6_IS8_SB_IS2_SaIS2_EEEElS3_EET1_T0_SJ_SI_T2_T3_:$/;"	l
_ZN14__gnu_parallel25multiway_merge_loser_treeINS_10_LoserTreeILb0EN9vec_uchar6item_tESt4lessIS3_EEEN9__gnu_cxx17__normal_iteratorIPSt4pairIPS3_SA_ESt6vectorISB_SaISB_EEEENS8_ISA_SD_IS3_SaIS3_EEEElS5_EET1_T0_SL_SK_T2_T3_	sparseSA.s	/^_ZN14__gnu_parallel25multiway_merge_loser_treeINS_10_LoserTreeILb0EN9vec_uchar6item_tESt4lessIS3_EEEN9__gnu_cxx17__normal_iteratorIPSt4pairIPS3_SA_ESt6vectorISB_SaISB_EEEENS8_ISA_SD_IS3_SaIS3_EEEElS5_EET1_T0_SL_SK_T2_T3_:$/;"	l
_ZN14__gnu_parallel27__sequential_multiway_mergeILb0ELb0EN9__gnu_cxx17__normal_iteratorIPSt4pairIP7match_tS5_ESt6vectorIS6_SaIS6_EEEENS2_IS5_S8_IS4_SaIS4_EEEEl6by_refEET2_T1_SH_SG_RKNSt15iterator_traitsINSI_ISH_E10value_type10first_typeEE10value_typeET3_T4_	sparseSA.s	/^_ZN14__gnu_parallel27__sequential_multiway_mergeILb0ELb0EN9__gnu_cxx17__normal_iteratorIPSt4pairIP7match_tS5_ESt6vectorIS6_SaIS6_EEEENS2_IS5_S8_IS4_SaIS4_EEEEl6by_refEET2_T1_SH_SG_RKNSt15iterator_traitsINSI_ISH_E10value_type10first_typeEE10value_typeET3_T4_:$/;"	l
_ZN14__gnu_parallel27__sequential_multiway_mergeILb0ELb0EN9__gnu_cxx17__normal_iteratorIPSt4pairIPN9vec_uchar6item_tES6_ESt6vectorIS7_SaIS7_EEEENS2_IS6_S9_IS5_SaIS5_EEEElSt4lessIS5_EEET2_T1_SJ_SI_RKNSt15iterator_traitsINSK_ISJ_E10value_type10first_typeEE10value_typeET3_T4_	sparseSA.s	/^_ZN14__gnu_parallel27__sequential_multiway_mergeILb0ELb0EN9__gnu_cxx17__normal_iteratorIPSt4pairIPN9vec_uchar6item_tES6_ESt6vectorIS7_SaIS7_EEEENS2_IS6_S9_IS5_SaIS5_EEEElSt4lessIS5_EEET2_T1_SJ_SI_RKNSt15iterator_traitsINSK_ISJ_E10value_type10first_typeEE10value_typeET3_T4_:$/;"	l
_ZN8sparseSA10computeLCPEv	sparseSA.s	/^_ZN8sparseSA10computeLCPEv:$/;"	l
_ZN8sparseSA11MUMParallelERSsiRSt6vectorI7match_tSaIS2_EEiRlb	sparseSA.s	/^_ZN8sparseSA11MUMParallelERSsiRSt6vectorI7match_tSaIS2_EEiRlb:$/;"	l
_ZN8sparseSA11collectMEMsERSsl10interval_tS1_RSt6vectorI7match_tSaIS3_EEib	sparseSA.s	/^_ZN8sparseSA11collectMEMsERSsl10interval_tS1_RSt6vectorI7match_tSaIS3_EEib:$/;"	l
_ZN8sparseSA11print_matchE7match_t	sparseSA.s	/^_ZN8sparseSA11print_matchE7match_t:$/;"	l
_ZN8sparseSA11print_matchE7match_tRSt6vectorIS0_SaIS0_EE	sparseSA.s	/^_ZN8sparseSA11print_matchE7match_tRSt6vectorIS0_SaIS0_EE:$/;"	l
_ZN8sparseSA11print_matchESsRSt6vectorI7match_tSaIS1_EEb	sparseSA.s	/^_ZN8sparseSA11print_matchESsRSt6vectorI7match_tSaIS1_EEb:$/;"	l
_ZN8sparseSA12computeChildEv	sparseSA.s	/^_ZN8sparseSA12computeChildEv:$/;"	l
_ZN8sparseSA3MEMERSsRSt6vectorI7match_tSaIS2_EEibRli	sparseSA.s	/^_ZN8sparseSA3MEMERSsRSt6vectorI7match_tSaIS2_EEibRli:$/;"	l
_ZN8sparseSA3MUMERSsRSt6vectorI7match_tSaIS2_EEiRlb	sparseSA.s	/^_ZN8sparseSA3MUMERSsRSt6vectorI7match_tSaIS2_EEiRlb:$/;"	l
_ZN8sparseSA7findMAMERSsiiRSt6vectorI7match_tSaIS2_EEiRlb	sparseSA.s	/^_ZN8sparseSA7findMAMERSsiiRSt6vectorI7match_tSaIS2_EEiRlb:$/;"	l
_ZN8sparseSA7findMEMElRSsRSt6vectorI7match_tSaIS2_EEib	sparseSA.s	/^_ZN8sparseSA7findMEMElRSsRSt6vectorI7match_tSaIS2_EEib:$/;"	l
_ZN8sparseSA9radixStepEPiS0_RlPllll	sparseSA.s	/^_ZN8sparseSA9radixStepEPiS0_RlPllll:$/;"	l
_ZN8sparseSAC2ERSsRSt6vectorISsSaISsEERS1_IlSaIlEEblbbib	sparseSA.s	/^_ZN8sparseSAC2ERSsRSt6vectorISsSaISsEERS1_IlSaIlEEblbbib:$/;"	l
_ZN8sparseSAD2Ev	mummer.s	/^_ZN8sparseSAD2Ev:$/;"	l
_ZNSt5stackIiSt6vectorIiSaIiEEED2Ev	sparseSA.s	/^_ZNSt5stackIiSt6vectorIiSaIiEEED2Ev:$/;"	l
_ZNSt6vectorI7match_tSaIS0_EE15_M_range_insertIN9__gnu_cxx17__normal_iteratorIPS0_S2_EEEEvS7_T_S8_St20forward_iterator_tag	sparseSA.s	/^_ZNSt6vectorI7match_tSaIS0_EE15_M_range_insertIN9__gnu_cxx17__normal_iteratorIPS0_S2_EEEEvS7_T_S8_St20forward_iterator_tag:$/;"	l
_ZNSt6vectorI7match_tSaIS0_EE19_M_emplace_back_auxIIRKS0_EEEvDpOT_	sparseSA.s	/^_ZNSt6vectorI7match_tSaIS0_EE19_M_emplace_back_auxIIRKS0_EEEvDpOT_:$/;"	l
_ZNSt6vectorI7match_tSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_	sparseSA.s	/^_ZNSt6vectorI7match_tSaIS0_EE19_M_emplace_back_auxIIS0_EEEvDpOT_:$/;"	l
_ZNSt6vectorI7match_tSaIS0_EED2Ev	sparseSA.s	/^_ZNSt6vectorI7match_tSaIS0_EED2Ev:$/;"	l
_ZNSt6vectorIN14__gnu_parallel6_PieceIlEESaIS2_EE17_M_default_appendEm	sparseSA.s	/^_ZNSt6vectorIN14__gnu_parallel6_PieceIlEESaIS2_EE17_M_default_appendEm:$/;"	l
_ZNSt6vectorIN9vec_uchar6item_tESaIS1_EE19_M_emplace_back_auxIIS1_EEEvDpOT_	sparseSA.s	/^_ZNSt6vectorIN9vec_uchar6item_tESaIS1_EE19_M_emplace_back_auxIIS1_EEEvDpOT_:$/;"	l
_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_	fasta.s	/^_ZNSt6vectorISsSaISsEE19_M_emplace_back_auxIIRKSsEEEvDpOT_:$/;"	l
_ZNSt6vectorISsSaISsEED2Ev	mummer.s	/^_ZNSt6vectorISsSaISsEED2Ev:$/;"	l
_ZNSt6vectorISt4pairI7match_tlESaIS2_EE19_M_emplace_back_auxIIS2_EEEvDpOT_	sparseSA.s	/^_ZNSt6vectorISt4pairI7match_tlESaIS2_EE19_M_emplace_back_auxIIS2_EEEvDpOT_:$/;"	l
_ZNSt6vectorISt4pairI7match_tlESaIS2_EED2Ev	sparseSA.s	/^_ZNSt6vectorISt4pairI7match_tlESaIS2_EED2Ev:$/;"	l
_ZNSt6vectorISt4pairIN9vec_uchar6item_tElESaIS3_EE19_M_emplace_back_auxIIS3_EEEvDpOT_	sparseSA.s	/^_ZNSt6vectorISt4pairIN9vec_uchar6item_tElESaIS3_EE19_M_emplace_back_auxIIS3_EEEvDpOT_:$/;"	l
_ZNSt6vectorISt4pairIN9vec_uchar6item_tElESaIS3_EED2Ev	sparseSA.s	/^_ZNSt6vectorISt4pairIN9vec_uchar6item_tElESaIS3_EED2Ev:$/;"	l
_ZNSt6vectorIhSaIhEE17_M_default_appendEm	sparseSA.s	/^_ZNSt6vectorIhSaIhEE17_M_default_appendEm:$/;"	l
_ZNSt6vectorIiSaIiEE17_M_default_appendEm	sparseSA.s	/^_ZNSt6vectorIiSaIiEE17_M_default_appendEm:$/;"	l
_ZNSt6vectorIiSaIiEE19_M_emplace_back_auxIIRKiEEEvDpOT_	sparseSA.s	/^_ZNSt6vectorIiSaIiEE19_M_emplace_back_auxIIRKiEEEvDpOT_:$/;"	l
_ZNSt6vectorIiSaIiEE19_M_emplace_back_auxIIiEEEvDpOT_	sparseSA.s	/^_ZNSt6vectorIiSaIiEE19_M_emplace_back_auxIIiEEEvDpOT_:$/;"	l
_ZNSt6vectorIiSaIiEED2Ev	sparseSA.s	/^_ZNSt6vectorIiSaIiEED2Ev:$/;"	l
_ZNSt6vectorIjSaIjEE17_M_default_appendEm	sparseSA.s	/^_ZNSt6vectorIjSaIjEE17_M_default_appendEm:$/;"	l
_ZNSt6vectorIlSaIlEE19_M_emplace_back_auxIIlEEEvDpOT_	fasta.s	/^_ZNSt6vectorIlSaIlEE19_M_emplace_back_auxIIlEEEvDpOT_:$/;"	l
_ZNSt6vectorIlSaIlEE19_M_emplace_back_auxIIlEEEvDpOT_	sparseSA.s	/^_ZNSt6vectorIlSaIlEE19_M_emplace_back_auxIIlEEEvDpOT_:$/;"	l
_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS2_SaIS2_EEEElS2_6by_refEvT_T0_SA_T1_T2_	sparseSA.s	/^_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS2_SaIS2_EEEElS2_6by_refEvT_T0_SA_T1_T2_:$/;"	l
_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIPN9vec_uchar6item_tESt6vectorIS3_SaIS3_EEEElS3_St4lessIS3_EEvT_T0_SC_T1_T2_	sparseSA.s	/^_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIPN9vec_uchar6item_tESt6vectorIS3_SaIS3_EEEElS3_St4lessIS3_EEvT_T0_SC_T1_T2_:$/;"	l
_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEElS4_N14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_T0_SF_T1_T2_	sparseSA.s	/^_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEElS4_N14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_T0_SF_T1_T2_:$/;"	l
_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEElS4_N14__gnu_parallel21_LexicographicReverseIS3_l6by_refEEEvT_T0_SF_T1_T2_	sparseSA.s	/^_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEElS4_N14__gnu_parallel21_LexicographicReverseIS3_l6by_refEEEvT_T0_SF_T1_T2_:$/;"	l
_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIPSt4pairIN9vec_uchar6item_tElESt6vectorIS5_SaIS5_EEEElS5_N14__gnu_parallel14_LexicographicIS4_lSt4lessIS4_EEEEvT_T0_SH_T1_T2_	sparseSA.s	/^_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIPSt4pairIN9vec_uchar6item_tElESt6vectorIS5_SaIS5_EEEElS5_N14__gnu_parallel14_LexicographicIS4_lSt4lessIS4_EEEEvT_T0_SH_T1_T2_:$/;"	l
_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIPSt4pairIN9vec_uchar6item_tElESt6vectorIS5_SaIS5_EEEElS5_N14__gnu_parallel21_LexicographicReverseIS4_lSt4lessIS4_EEEEvT_T0_SH_T1_T2_	sparseSA.s	/^_ZSt13__adjust_heapIN9__gnu_cxx17__normal_iteratorIPSt4pairIN9vec_uchar6item_tElESt6vectorIS5_SaIS5_EEEElS5_N14__gnu_parallel21_LexicographicReverseIS4_lSt4lessIS4_EEEEvT_T0_SH_T1_T2_:$/;"	l
_ZSt13__adjust_heapIP7match_tlS0_6by_refEvT_T0_S4_T1_T2_	sparseSA.s	/^_ZSt13__adjust_heapIP7match_tlS0_6by_refEvT_T0_S4_T1_T2_:$/;"	l
_ZSt13__adjust_heapIPN9vec_uchar6item_tElS1_St4lessIS1_EEvT_T0_S6_T1_T2_	sparseSA.s	/^_ZSt13__adjust_heapIPN9vec_uchar6item_tElS1_St4lessIS1_EEvT_T0_S6_T1_T2_:$/;"	l
_ZSt13__heap_selectIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEEN14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_SE_SE_T0_	sparseSA.s	/^_ZSt13__heap_selectIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEEN14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_SE_SE_T0_:$/;"	l
_ZSt16__insertion_sortIN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS2_SaIS2_EEEE6by_refEvT_S9_T0_	sparseSA.s	/^_ZSt16__insertion_sortIN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS2_SaIS2_EEEE6by_refEvT_S9_T0_:$/;"	l
_ZSt16__insertion_sortIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEEN14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_SE_T0_	sparseSA.s	/^_ZSt16__insertion_sortIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEEN14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_SE_T0_:$/;"	l
_ZSt16__insertion_sortIN9__gnu_cxx17__normal_iteratorIPSt4pairIN9vec_uchar6item_tElESt6vectorIS5_SaIS5_EEEEN14__gnu_parallel14_LexicographicIS4_lSt4lessIS4_EEEEvT_SG_T0_	sparseSA.s	/^_ZSt16__insertion_sortIN9__gnu_cxx17__normal_iteratorIPSt4pairIN9vec_uchar6item_tElESt6vectorIS5_SaIS5_EEEEN14__gnu_parallel14_LexicographicIS4_lSt4lessIS4_EEEEvT_SG_T0_:$/;"	l
_ZSt16__insertion_sortIP7match_t6by_refEvT_S3_T0_	sparseSA.s	/^_ZSt16__insertion_sortIP7match_t6by_refEvT_S3_T0_:$/;"	l
_ZSt16__introsort_loopIN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS2_SaIS2_EEEEl6by_refEvT_S9_T0_T1_	sparseSA.s	/^_ZSt16__introsort_loopIN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS2_SaIS2_EEEEl6by_refEvT_S9_T0_T1_:$/;"	l
_ZSt16__introsort_loopIN9__gnu_cxx17__normal_iteratorIPN9vec_uchar6item_tESt6vectorIS3_SaIS3_EEEElSt4lessIS3_EEvT_SB_T0_T1_	sparseSA.s	/^_ZSt16__introsort_loopIN9__gnu_cxx17__normal_iteratorIPN9vec_uchar6item_tESt6vectorIS3_SaIS3_EEEElSt4lessIS3_EEvT_SB_T0_T1_:$/;"	l
_ZSt16__introsort_loopIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEElN14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_SE_T0_T1_	sparseSA.s	/^_ZSt16__introsort_loopIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEElN14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_SE_T0_T1_:$/;"	l
_ZSt16__introsort_loopIN9__gnu_cxx17__normal_iteratorIPSt4pairIN9vec_uchar6item_tElESt6vectorIS5_SaIS5_EEEElN14__gnu_parallel14_LexicographicIS4_lSt4lessIS4_EEEEvT_SG_T0_T1_	sparseSA.s	/^_ZSt16__introsort_loopIN9__gnu_cxx17__normal_iteratorIPSt4pairIN9vec_uchar6item_tElESt6vectorIS5_SaIS5_EEEElN14__gnu_parallel14_LexicographicIS4_lSt4lessIS4_EEEEvT_SG_T0_T1_:$/;"	l
_ZSt16__introsort_loopIP7match_tl6by_refEvT_S3_T0_T1_	sparseSA.s	/^_ZSt16__introsort_loopIP7match_tl6by_refEvT_S3_T0_T1_:$/;"	l
_ZSt16__introsort_loopIPN9vec_uchar6item_tElSt4lessIS1_EEvT_S5_T0_T1_	sparseSA.s	/^_ZSt16__introsort_loopIPN9vec_uchar6item_tElSt4lessIS1_EEvT_S5_T0_T1_:$/;"	l
_ZSt19__move_median_firstIN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS2_SaIS2_EEEE6by_refEvT_S9_S9_T0_	sparseSA.s	/^_ZSt19__move_median_firstIN9__gnu_cxx17__normal_iteratorIP7match_tSt6vectorIS2_SaIS2_EEEE6by_refEvT_S9_S9_T0_:$/;"	l
_ZSt19__move_median_firstIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEEN14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_SE_SE_T0_	sparseSA.s	/^_ZSt19__move_median_firstIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEEN14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_SE_SE_T0_:$/;"	l
_ZSt19__move_median_firstIN9__gnu_cxx17__normal_iteratorIPSt4pairIN9vec_uchar6item_tElESt6vectorIS5_SaIS5_EEEEN14__gnu_parallel14_LexicographicIS4_lSt4lessIS4_EEEEvT_SG_SG_T0_	sparseSA.s	/^_ZSt19__move_median_firstIN9__gnu_cxx17__normal_iteratorIPSt4pairIN9vec_uchar6item_tElESt6vectorIS5_SaIS5_EEEEN14__gnu_parallel14_LexicographicIS4_lSt4lessIS4_EEEEvT_SG_SG_T0_:$/;"	l
_ZSt20__replacement_assertPKciS0_S0_	sparseSA.s	/^_ZSt20__replacement_assertPKciS0_S0_:$/;"	l
_ZSt21__unguarded_partitionIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEES4_N14__gnu_parallel14_LexicographicIS3_l6by_refEEET_SE_SE_RKT0_T1_	sparseSA.s	/^_ZSt21__unguarded_partitionIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEES4_N14__gnu_parallel14_LexicographicIS3_l6by_refEEET_SE_SE_RKT0_T1_:$/;"	l
_ZSt25__unguarded_linear_insertIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEEN14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_T0_	sparseSA.s	/^_ZSt25__unguarded_linear_insertIN9__gnu_cxx17__normal_iteratorIPSt4pairI7match_tlESt6vectorIS4_SaIS4_EEEEN14__gnu_parallel14_LexicographicIS3_l6by_refEEEvT_T0_:$/;"	l
_ZZ4mainE12long_options	mummer.s	/^_ZZ4mainE12long_options:$/;"	l
_ZZN14__gnu_parallel18multiseq_partitionIN9__gnu_cxx17__normal_iteratorIPSt4pairIP7match_tS5_ESt6vectorIS6_SaIS6_EEEElNS2_IPS5_S8_IS5_SaIS5_EEEE6by_refEEvT_SH_T0_T1_T2_E19__PRETTY_FUNCTION__	sparseSA.s	/^_ZZN14__gnu_parallel18multiseq_partitionIN9__gnu_cxx17__normal_iteratorIPSt4pairIP7match_tS5_ESt6vectorIS6_SaIS6_EEEElNS2_IPS5_S8_IS5_SaIS5_EEEE6by_refEEvT_SH_T0_T1_T2_E19__PRETTY_FUNCTION__:$/;"	l
_ZZN14__gnu_parallel18multiseq_partitionIN9__gnu_cxx17__normal_iteratorIPSt4pairIPN9vec_uchar6item_tES6_ESt6vectorIS7_SaIS7_EEEElNS2_IPS6_S9_IS6_SaIS6_EEEESt4lessIS5_EEEvT_SJ_T0_T1_T2_E19__PRETTY_FUNCTION__	sparseSA.s	/^_ZZN14__gnu_parallel18multiseq_partitionIN9__gnu_cxx17__normal_iteratorIPSt4pairIPN9vec_uchar6item_tES6_ESt6vectorIS7_SaIS7_EEEElNS2_IPS6_S9_IS6_SaIS6_EEEESt4lessIS5_EEEvT_SJ_T0_T1_T2_E19__PRETTY_FUNCTION__:$/;"	l
__FASTA_HPP__	fasta.hpp	2;"	d
__sparseSA_hpp__	sparseSA.hpp	2;"	d
activeblocks	space.cpp	/^void activeblocks(void)$/;"	f
addEvent	PapiCounter.h	/^void PapiCounterList::addEvent(std::string ename){$/;"	f	class:PapiCounterList
addoption	procopt.cpp	/^Sint addoption(OptionDescription *options,Uint numofoptions,$/;"	f
address	streetyp.h	/^  Uint *address;$/;"	m	struct:Reference
addspace	space.cpp	/^static void addspace(Uint space)$/;"	f	file:
allocandusespaceviaptr	space.cpp	/^\/*@notnull@*\/ void *allocandusespaceviaptr(char *file,Uint line, $/;"	f
allocatedStrings	arraydef.h	/^  Uint stringbufferlength, nextfreeStrings, allocatedStrings;$/;"	m	struct:ArrayStrings
alphabet	streetyp.h	/^  Uchar *alphabet;$/;"	m	struct:Suffixtree
alphasize	streetyp.h	/^       alphasize,             \/\/ the number of different characters in t$/;"	m	struct:Suffixtree
automatic	mummer.cpp	/^bool automatic = true;$/;"	v
automatic	mummer.mod.cpp	/^bool automatic = true;$/;"	v
automatic	mummer.pomp.cpp	/^bool automatic = true;$/;"	v
automatic	mummer.s	/^automatic:$/;"	l
automaticSkip	mummer.cpp	/^bool automaticSkip = true;$/;"	v
automaticSkip	mummer.mod.cpp	/^bool automaticSkip = true;$/;"	v
automaticSkip	mummer.pomp.cpp	/^bool automaticSkip = true;$/;"	v
automaticSkip	mummer.s	/^automaticSkip:$/;"	l
base	genDNA.py	/^    base = randint(1,4)$/;"	v
blocks	space.cpp	/^\/*@null@*\/ static Blockdescription *blocks = NULL;$/;"	v	file:
branchbrother	streetyp.h	/^            branchbrother;  \/\/ the reference to the right brother; $/;"	m	struct:Branchinfo
branchnodeoffset	streetyp.h	/^       branchnodeoffset,      \/\/ number of leafs in tree$/;"	m	struct:Suffixtree
branchtab	streetyp.h	/^       *branchtab,            \/\/ table TBranch$/;"	m	struct:Suffixtree
bsearch_left	sparseSA.cpp	/^long sparseSA::bsearch_left(char c, long i, long s, long e) {$/;"	f	class:sparseSA
bsearch_left	sparseSA.mod.cpp	/^long sparseSA::bsearch_left(char c, long i, long s, long e) {$/;"	f	class:sparseSA
bsearch_left	sparseSA.pomp.cpp	/^long sparseSA::bsearch_left(char c, long i, long s, long e) {$/;"	f	class:sparseSA
bsearch_right	sparseSA.cpp	/^long sparseSA::bsearch_right(char c, long i, long s, long e) {$/;"	f	class:sparseSA
bsearch_right	sparseSA.mod.cpp	/^long sparseSA::bsearch_right(char c, long i, long s, long e) {$/;"	f	class:sparseSA
bsearch_right	sparseSA.pomp.cpp	/^long sparseSA::bsearch_right(char c, long i, long s, long e) {$/;"	f	class:sparseSA
bucketsort	qsufsort.c	/^static void bucketsort(int *x, int *p, int n, int k)$/;"	f	file:
by_ref	sparseSA.cpp	/^struct by_ref { bool operator() (const match_t &a, const match_t &b) const { if(a.ref == b.ref) return a.len > b.len; else return a.ref < b.ref; }  };$/;"	s	file:
by_ref	sparseSA.mod.cpp	/^struct by_ref { bool operator() (const match_t &a, const match_t &b) const { if(a.ref == b.ref) return a.len > b.len; else return a.ref < b.ref; }  };$/;"	s	file:
by_ref	sparseSA.pomp.cpp	/^struct by_ref { bool operator() (const match_t &a, const match_t &b) const { if(a.ref == b.ref) return a.len > b.len; else return a.ref < b.ref; }  };$/;"	s	file:
chainstart	streetyp.h	/^       *chainstart,           \/\/ address of the node, current chains starts at$/;"	m	struct:Suffixtree
checkdoubleexclude	procopt.cpp	/^int checkdoubleexclude(Uint numofopts,OptionDescription *opt,$/;"	f
checkexclude	procopt.cpp	/^int checkexclude(OptionDescription *opt,Sint *excludetab,Uint len)$/;"	f
checklocation	streedbg.cpp	/^void checklocation(Suffixtree *stree,Location *loc)$/;"	f
checkspaceleak	space.cpp	/^void checkspaceleak(void)$/;"	f
checkstree	streedbg.cpp	/^void checkstree(Suffixtree *stree)$/;"	f
child	mummer.cpp	/^bool child = true;$/;"	v
child	mummer.mod.cpp	/^bool child = true;$/;"	v
child	mummer.pomp.cpp	/^bool child = true;$/;"	v
child	mummer.s	/^child:$/;"	l
choose_pivot	qsufsort.c	/^static int choose_pivot(int *p, int n) {$/;"	f	file:
chunks	maxmatdef.h	/^       chunks,                  \/\/ number of chunks to split query sequence$/;"	m	struct:MMcallinfo
chunks	maxmatdef.h	/^       chunks,                 \/\/  number of chunks to split query sequence$/;"	m	struct:Matchprocessinfo
chunks	mummer.cpp	/^int chunks = 1;$/;"	v
chunks	mummer.mod.cpp	/^int chunks = 1;$/;"	v
chunks	mummer.pomp.cpp	/^int chunks = 1;$/;"	v
chunks	mummer.s	/^chunks:$/;"	l
cmaxmatch	maxmatdef.h	/^       cmaxmatch,               \/\/ compute all maximal matches$/;"	m	struct:MMcallinfo
cmum	maxmatdef.h	/^       cmum,                   \/\/ compute MUMs$/;"	m	struct:Matchprocessinfo
cmum	maxmatdef.h	/^       cmum;                    \/\/ compute real matches unique in both sequences$/;"	m	struct:MMcallinfo
cmumcand	maxmatdef.h	/^       cmumcand,                \/\/ compute reference-unique maximal matches$/;"	m	struct:MMcallinfo
cmumcand	maxmatdef.h	/^       cmumcand,               \/\/ compute MUM candidates$/;"	m	struct:Matchprocessinfo
collectMEMs	sparseSA.cpp	/^void sparseSA::collectMEMs(string &P, long prefix, interval_t mli, interval_t xmi, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
collectMEMs	sparseSA.mod.cpp	/^void sparseSA::collectMEMs(string &P, long prefix, interval_t mli, interval_t xmi, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
collectMEMs	sparseSA.pomp.cpp	/^void sparseSA::collectMEMs(string &P, long prefix, interval_t mli, interval_t xmi, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
commondepthstack	findmaxmat.cpp	/^  ArrayNodeinfo commondepthstack; \/\/ stack to store depth values$/;"	m	struct:Maxmatchinfo	file:
compareMUMcandidates	cleanMUMcand.cpp	/^static Sint compareMUMcandidates(MUMcandidate *p,MUMcandidate *q)$/;"	f	file:
comparelocs	streedbg.cpp	/^static Sint comparelocs(Suffixtree *stree,Location *loc1,Location *loc2)$/;"	f	file:
completelarge	construct.cpp	/^static void completelarge(Suffixtree *stree)$/;"	f	file:
computeChild	sparseSA.cpp	/^void sparseSA::computeChild() {$/;"	f	class:sparseSA
computeChild	sparseSA.mod.cpp	/^void sparseSA::computeChild() {$/;"	f	class:sparseSA
computeChild	sparseSA.pomp.cpp	/^void sparseSA::computeChild() {$/;"	f	class:sparseSA
computeLCP	sparseSA.cpp	/^void sparseSA::computeLCP() {$/;"	f	class:sparseSA
computeLCP	sparseSA.mod.cpp	/^void sparseSA::computeLCP() {$/;"	f	class:sparseSA
computeLCP	sparseSA.pomp.cpp	/^void sparseSA::computeLCP() {$/;"	f	class:sparseSA
constructprogressstree	construct.cpp	/^Sint constructprogressstree(Suffixtree *stree,Uchar *text,Uint textlen,void (*progress)(Uint,void *),void (*finalprogress)(void *),void *info)$/;"	f
count	PapiCounter.h	/^    long long   count(int tid, int i)  { assert(tid<threads()); return counts_[tid][i]; };$/;"	f	class:PapiCounter
count	PapiCounter.h	/^long long PapiCounter::count(int i){$/;"	f	class:PapiCounter
counter	PapiCounter.h	/^    long long counter(int tid, int i){$/;"	f	class:Papi
counters	PapiCounter.h	/^    int         counters()    { return names_.size(); };$/;"	f	class:PapiCounter
counters_	PapiCounter.h	/^    std::vector<std::vector<long long> > counters_;$/;"	m	class:Papi
counting	PapiCounter.h	/^    bool counting() { return counting_; };$/;"	f	class:Papi
counting_	PapiCounter.h	/^    bool counting_;$/;"	m	class:Papi
counts	PapiCounter.h	/^std::vector<long long> PapiCounter::counts(int i){$/;"	f	class:PapiCounter
counts_	PapiCounter.h	/^    std::vector<std::vector<long long> >   counts_;$/;"	m	class:PapiCounter
cout_mutex	sparseSA.cpp	/^pthread_mutex_t cout_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
cout_mutex	sparseSA.mod.cpp	/^pthread_mutex_t cout_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
cout_mutex	sparseSA.pomp.cpp	/^pthread_mutex_t cout_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
cout_mutex	sparseSA.s	/^cout_mutex:$/;"	l
createTable	distribute.cpp	/^void createTable(Matchprocessinfo *matchprocessinfo) $/;"	f
creatememorymap	mapfile.cpp	/^\/*@null@*\/ void *creatememorymap(char *file,Uint line,char *filename,bool writemap,Uint *numofbytes)$/;"	f
creatememorymapforfiledesc	mapfile.cpp	/^\/*@null@*\/ void *creatememorymapforfiledesc(char *file,Uint line,Sint fd,bool writemap,Uint $/;"	f
currentbranchtabsize	streetyp.h	/^       currentbranchtabsize,  \/\/ current number of cells in branchtab$/;"	m	struct:Suffixtree
currentdepth	streetyp.h	/^       currentdepth,          \/\/ depth of the new branch node$/;"	m	struct:Suffixtree
currentisrcmatch	maxmatdef.h	/^       currentisrcmatch;       \/\/ true iff currently rc-matches are computed$/;"	m	struct:Matchprocessinfo
currentquerylen	maxmatdef.h	/^       currentquerylen;        \/\/ length of the current query sequence$/;"	m	struct:Matchprocessinfo
currentspace	mapfile.cpp	/^static Uint currentspace = 0,              \/\/ currently mapped num of bytes$/;"	v	file:
currentspace	space.cpp	/^            currentspace = 0,   \/\/ currently allocated num of bytes$/;"	v	file:
dbstart	mumcand.h	/^       dbstart,      \/\/ start position in the subject-sequence$/;"	m	struct:MUMcandidate
debug_	PapiCounter.h	/^    bool debug_;$/;"	m	class:Papi
declared	optdesc.h	/^       declared;             \/\/ is the option declared by$/;"	m	struct:OptionDescription
defined	multidef.h	/^  bool defined,          \/\/ show a description$/;"	m	struct:Showdescinfo
deletememorymap	mapfile.cpp	/^Sint deletememorymap(char *file,Uint line,void *mappedfile)$/;"	f
depth	maxmatdef.h	/^    Uint depth, position;$/;"	m	struct:suffix
depth	sparseSA.hpp	/^  long depth, start, end, lb, rb;$/;"	m	struct:interval_t
depth	streetyp.h	/^       depth;               \/\/ the depth of the branching node$/;"	m	struct:Branchinfo
depth	streetyp.h	/^  Uint depth, headposition;$/;"	m	struct:Pathinfo
depthfirststree	dfs.cpp	/^Sint depthfirststree(Suffixtree *stree,Reference *startnode,$/;"	f
depthofpreviousmaxloc	findmaxmat.cpp	/^       depthofpreviousmaxloc;     \/\/ the depth of the previous maxloc$/;"	m	struct:Maxmatchinfo	file:
derivedStat	PapiCounter.h	/^enum derivedStat{$/;"	g
derivedStatAvailable	PapiCounter.h	/^bool PapiCounter::derivedStatAvailable(derivedStat statIDX){$/;"	f	class:PapiCounter
derivedStatCompute	PapiCounter.h	/^std::vector<double> PapiCounter::derivedStatCompute(derivedStat statIDX){$/;"	f	class:PapiCounter
derivedStatName	PapiCounter.h	/^std::string derivedStatName(derivedStat statIDX){$/;"	f
derived_BANDWIDTH_DS	PapiCounter.h	/^    derived_BANDWIDTH_DS$/;"	e	enum:derivedStat
derived_BANDWIDTH_SS	PapiCounter.h	/^    derived_BANDWIDTH_SS,$/;"	e	enum:derivedStat
derived_FLOPS	PapiCounter.h	/^    derived_FLOPS,$/;"	e	enum:derivedStat
derived_L1_DMR	PapiCounter.h	/^    derived_L1_DMR,$/;"	e	enum:derivedStat
derived_L1_TMR	PapiCounter.h	/^    derived_L1_TMR,$/;"	e	enum:derivedStat
derived_L2_DMR	PapiCounter.h	/^    derived_L2_DMR,$/;"	e	enum:derivedStat
derived_L2_TMR	PapiCounter.h	/^    derived_L2_TMR,$/;"	e	enum:derivedStat
descr	sparseSA.hpp	/^  vector<string> &descr; \/\/ Descriptions of concatenated sequences.$/;"	m	struct:sparseSA
description	optdesc.h	/^       *description;         \/\/ help text describing purpose of option$/;"	m	struct:OptionDescription
descspace	multidef.h	/^  ArrayCharacters descspace;           \/\/ the space for the descriptions$/;"	m	struct:Multiseq
dna	genDNA.py	/^dna = {1 : "a", 2 : "c", 3 : "g", 4 : "t"}$/;"	v
dynamicstrdup	space.cpp	/^\/*@notnull@*\/ char *dynamicstrdup(char *file,Uint line,char *source)$/;"	f
edgelen	streetyp.h	/^  Uint edgelen,         \/\/ length of edge$/;"	m	struct:Location
encoding	distribute.cpp	/^Uint encoding(Uchar *example, int wordsize) $/;"	f
end	sparseSA.hpp	/^  long depth, start, end, lb, rb;$/;"	m	struct:interval_t
enumeratemaxmatches	findmaxmat.cpp	/^static Sint enumeratemaxmatches (Maxmatchinfo *maxmatchinfo,$/;"	f	file:
enumlocations	streedbg.cpp	/^void enumlocations(Suffixtree *stree,$/;"	f
enumlocationssubtree	streedbg.cpp	/^static void enumlocationssubtree(Suffixtree *stree,Uint *btptr,$/;"	f	file:
errorcode	seterror.cpp	/^static Sint errorcode = 0;$/;"	v	file:
errormessage	seterror.cpp	/^static char errormessage[MAXERRORMSG+1];$/;"	v	file:
event	PapiCounter.h	/^PapiCounter& PapiCounterList::event(std::string ename){$/;"	f	class:PapiCounterList
eventName	PapiCounter.h	/^    std::string const &eventName(int i){$/;"	f	class:Papi::std
eventNames_	PapiCounter.h	/^    std::vector<std::string> eventNames_;$/;"	m	class:Papi
eventNumber	PapiCounter.h	/^    int eventNumber(int i){$/;"	f	class:Papi
eventSet_	PapiCounter.h	/^    int eventSet_;$/;"	m	class:Papi
events_	PapiCounter.h	/^    std::map<std::string, PapiCounter> events_;$/;"	m	class:PapiCounterList
events_	PapiCounter.h	/^    std::vector<int> events_;$/;"	m	class:Papi
expand_link	sparseSA.hpp	/^  inline bool expand_link(interval_t &link) {$/;"	f	struct:sparseSA
fileFormatLaTeX	PapiCounter.h	/^enum papiFileFormat {fileFormatMatlab, fileFormatPlain, fileFormatLaTeX};$/;"	e	enum:papiFileFormat
fileFormatMatlab	PapiCounter.h	/^enum papiFileFormat {fileFormatMatlab, fileFormatPlain, fileFormatLaTeX};$/;"	e	enum:papiFileFormat
fileFormatPlain	PapiCounter.h	/^enum papiFileFormat {fileFormatMatlab, fileFormatPlain, fileFormatLaTeX};$/;"	e	enum:papiFileFormat
fileallocated	space.cpp	/^  char *fileallocated; \/\/ the filenames where the block was allocated$/;"	m	struct:Blockdescription	file:
filemapped	mapfile.cpp	/^static char *filemapped[MAXMAPPEDFILES] = {NULL};  $/;"	v	file:
fillTable	distribute.cpp	/^void fillTable(Suffixtree *stree, Table& table, Uchar *buffer,Uint *btptr, short int wordsize)$/;"	f
findMAM	sparseSA.cpp	/^void sparseSA::findMAM(string &P, int chunk, int chunks, vector<match_t> &matches, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
findMAM	sparseSA.mod.cpp	/^void sparseSA::findMAM(string &P, int chunk, int chunks, vector<match_t> &matches, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
findMAM	sparseSA.pomp.cpp	/^void sparseSA::findMAM(string &P, int chunk, int chunks, vector<match_t> &matches, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
findMEM	sparseSA.cpp	/^void sparseSA::findMEM(long k, string &P, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
findMEM	sparseSA.mod.cpp	/^void sparseSA::findMEM(long k, string &P, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
findMEM	sparseSA.pomp.cpp	/^void sparseSA::findMEM(long k, string &P, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
findString	PapiCounter.h	/^int findString(std::vector<std::string> const& strVec, std::string str){$/;"	f
find_Lmaximal	sparseSA.cpp	/^void sparseSA::find_Lmaximal(string &P, long prefix, long i, long len, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
find_Lmaximal	sparseSA.mod.cpp	/^void sparseSA::find_Lmaximal(string &P, long prefix, long i, long len, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
find_Lmaximal	sparseSA.pomp.cpp	/^void sparseSA::find_Lmaximal(string &P, long prefix, long i, long len, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
findmaxmatches	findmaxmat.cpp	/^Sint findmaxmatches(Uchar *reference,$/;"	f
findmaxmatchesonbothstrands	procmaxmat.cpp	/^static Sint findmaxmatchesonbothstrands(void *info,Uint seqnum,$/;"	f	file:
findmumcandidates	findmumcand.cpp	/^Sint findmumcandidates(Uchar *reference, Uint referencelen, Table &table, Uint minmatchlength, Uint chunks, Uint prefix, Processmatchfunction processmumcandidate, void *processinfo, Uchar *query, Uint querylen, Uint seqnum)$/;"	f
findprefixpathfromnodestree	scanpref.cpp	/^\/*@null@*\/Uchar *findprefixpathfromnodestree(Suffixtree *stree,$/;"	f
findprefixpathstree	scanpref.cpp	/^\/*@null@*\/ Uchar *findprefixpathstree(Suffixtree *stree,$/;"	f
firstchild	streetyp.h	/^  Reference firstchild,     \/\/ the reference to the first child$/;"	m	struct:Branchinfo
firstnotallocated	streetyp.h	/^       *firstnotallocated,    \/\/ refers to the last address, such that at$/;"	m	struct:Suffixtree
firstptr	streetyp.h	/^  Uchar *firstptr;     \/\/ pointer to first character of edge label$/;"	m	struct:Location
forward	maxmatdef.h	/^       forward,                 \/\/ compute matches on forward strand$/;"	m	struct:MMcallinfo
forward	maxmatdef.h	/^       forward,                \/\/ compute forward matches$/;"	m	struct:Matchprocessinfo
forwards	mummer.cpp	/^bool forwards = true;$/;"	v
forwards	mummer.mod.cpp	/^bool forwards = true;$/;"	v
forwards	mummer.pomp.cpp	/^bool forwards = true;$/;"	v
forwards	mummer.s	/^forwards:$/;"	l
fourcolumn	maxmatdef.h	/^       fourcolumn,              \/\/ always use 4 column format$/;"	m	struct:MMcallinfo
fourcolumn	maxmatdef.h	/^       fourcolumn,             \/\/ is option \\texttt{-F} on?$/;"	m	struct:Matchprocessinfo
freemultiseq	multiseq.cpp	/^void freemultiseq(Multiseq *multiseq)$/;"	f
freespaceviaptr	space.cpp	/^void freespaceviaptr(char *file,Uint line,void *ptr)$/;"	f
freestree	construct.cpp	/^void freestree(Suffixtree *stree)$/;"	f
from_set	sparseSA.hpp	/^  void from_set(long hit, long &seq, long &seqpos) {$/;"	f	struct:sparseSA
generalcounter	streetyp.h	/^  void *generalcounter;$/;"	m	struct:Suffixtree
getMaxNodesNumber	streedbg.cpp	/^Uint getMaxNodesNumber(Suffixtree *stree)$/;"	f
getbranchinfostree	access.cpp	/^void getbranchinfostree(Suffixtree *stree,Uint whichinfo,$/;"	f
geterror	seterror.cpp	/^Sint geterror(void)$/;"	f
getheadstringstree	access.cpp	/^void getheadstringstree(Suffixtree *stree,Stringtype *str)$/;"	f
getlargelinkconstruction	construct.cpp	/^static Uint getlargelinkconstruction(Suffixtree *stree)$/;"	f	file:
getlargelinkstree	access.cpp	/^Uint getlargelinkstree(\/*@unused@*\/ Suffixtree *stree,Bref btptr,Uint depth)$/;"	f
getleafinfostree	access.cpp	/^void getleafinfostree(Suffixtree *stree,Leafinfo *leafinfo,Lref lptr)$/;"	f
getmaxdesclen	procmaxmat.cpp	/^static Sint getmaxdesclen(Multiseq *multiseq)$/;"	f	file:
getmaxmatinput	maxmatinp.cpp	/^Sint getmaxmatinput (Multiseq *subjectmultiseq, bool matchnucleotidesonly, char *subjectfile)$/;"	f
getmaxtextlenstree	access.cpp	/^Uint getmaxtextlenstree(void)$/;"	f
getoptindent	procopt.cpp	/^static Uint getoptindent(int *excludetab,OptionDescription *opt,Uint numofopt)$/;"	f	file:
getrecordnum	multiseq.cpp	/^Sint getrecordnum(Uint *recordseps,Uint numofrecords,Uint totalwidth,$/;"	f
getseqnum	multiseq.cpp	/^Sint getseqnum(Multiseq *multiseq,Uint position)$/;"	f
getspacepeak	space.cpp	/^Uint getspacepeak(void)$/;"	f
h	qsufsort.c	/^   h;                           \/* length of already-sorted prefixes.*\/$/;"	v	file:
hasChild	sparseSA.hpp	/^  bool hasChild;$/;"	m	struct:sparseSA
hasSufLink	sparseSA.hpp	/^  bool hasSufLink;$/;"	m	struct:sparseSA
headend	streetyp.h	/^         *headend,            \/\/ of the head location \\((\\overline{u},v)\\). $/;"	m	struct:Suffixtree
headnode	streetyp.h	/^       *headnode,             \/\/ left component of head location$/;"	m	struct:Suffixtree
headnodedepth	streetyp.h	/^       headnodedepth,         \/\/ the depth of the headnode$/;"	m	struct:Suffixtree
headposition	streetyp.h	/^  Uint depth, headposition;$/;"	m	struct:Pathinfo
headposition	streetyp.h	/^  Uint headposition,        \/\/ the head position of the branching node$/;"	m	struct:Branchinfo
headstart	streetyp.h	/^  Uchar *headstart,          \/\/ these references represent the right component$/;"	m	struct:Suffixtree
idx	sparseSA.hpp	/^    size_t idx; int val;$/;"	m	struct:vec_uchar::item_t
inheritfrompath	findmaxmat.cpp	/^static void inheritfrompath(ArrayPathinfo *matchpath,Location *maxloc,Nodeinfo *stacktop,Bref nodeptr,Uint accessindex,Uint inheritdepth)$/;"	f	file:
init	PapiCounter.h	/^void Papi::init(){$/;"	f	class:Papi
init	sparseSA.hpp	/^  void init() {$/;"	f	struct:vec_uchar
initSuffixtree	construct.cpp	/^static void initSuffixtree(Suffixtree *stree,Uchar *text,Uint textlen)$/;"	f	file:
initmultiseq	multiseq.cpp	/^void initmultiseq(Multiseq *multiseq)$/;"	f
initoptions	procopt.cpp	/^void initoptions(OptionDescription *options,Uint numofoptions)$/;"	f
insertbranchnode	construct.cpp	/^static void insertbranchnode(Suffixtree *stree)$/;"	f	file:
insertinleaflist	dfs.cpp	/^static Sint insertinleaflist(Uint leafindex,\/*@unused@*\/ Bref lcpnode,$/;"	f	file:
insertleaf	construct.cpp	/^static void insertleaf(Suffixtree *stree)$/;"	f	file:
insertleafcalls	streetyp.h	/^  Uint insertleafcalls,$/;"	m	struct:Suffixtree
insertnode	streetyp.h	/^       insertnode,            \/\/ the node the split edge leads to $/;"	m	struct:Suffixtree
insertprev	streetyp.h	/^       insertprev,            \/\/ the edge preceeding the split edge$/;"	m	struct:Suffixtree
inside	sparseSA.hpp	/^  bool inside() { if (lb <= start && start <= rb && lb <= end && end <= rb) return true; else return false; }$/;"	f	struct:interval_t
instance	PapiCounter.h	/^Papi* Papi::instance(){$/;"	f	class:Papi
instance_	PapiCounter.h	/^    static Papi* instance_;$/;"	m	class:Papi
instance_	PapiCounter.h	/^Papi* Papi::instance_ = 0;$/;"	m	class:Papi
int2ref	access.cpp	/^static void int2ref(Suffixtree *stree,Reference *ref,Uint i)$/;"	f	file:
interval_t	sparseSA.hpp	/^  interval_t() { start = 1; end = 0; depth = -1; lb = start; rb = end; }$/;"	f	struct:interval_t
interval_t	sparseSA.hpp	/^  interval_t(long s, long e, long d, long l, long r) { start = s; end = e; depth = d; lb = l; rb = r; }$/;"	f	struct:interval_t
interval_t	sparseSA.hpp	/^struct interval_t {$/;"	s
is_leftmaximal	sparseSA.cpp	/^bool sparseSA::is_leftmaximal(string &P, long p1, long p2) {$/;"	f	class:sparseSA
is_leftmaximal	sparseSA.mod.cpp	/^bool sparseSA::is_leftmaximal(string &P, long p1, long p2) {$/;"	f	class:sparseSA
is_leftmaximal	sparseSA.pomp.cpp	/^bool sparseSA::is_leftmaximal(string &P, long p1, long p2) {$/;"	f	class:sparseSA
isalreadyset	optdesc.h	/^  bool isalreadyset,         \/\/ has the option already been set?$/;"	m	struct:OptionDescription
item_t	sparseSA.hpp	/^    item_t(size_t i, int v) { idx = i; val = v; }$/;"	f	struct:vec_uchar::item_t
item_t	sparseSA.hpp	/^  struct item_t{$/;"	s	struct:vec_uchar
largelinklinkwork	streetyp.h	/^       largelinklinkwork,$/;"	m	struct:Suffixtree
largelinks	streetyp.h	/^       largelinks,$/;"	m	struct:Suffixtree
largelinkwork	streetyp.h	/^       largelinkwork,$/;"	m	struct:Suffixtree
largenode	streetyp.h	/^       largenode,             \/\/ number of large nodes$/;"	m	struct:Suffixtree
lastcharindex	streetyp.h	/^  Sint lastcharindex;$/;"	m	struct:Suffixtree
lb	sparseSA.hpp	/^  long depth, start, end, lb, rb;$/;"	m	struct:interval_t
lcp	findmumcand.cpp	/^static Uint lcp(Uchar *start1,Uchar *end1,Uchar *start2,Uchar *end2)$/;"	f	file:
lcp	scanpref.cpp	/^static Uint lcp(Uchar *start1,Uchar *end1,Uchar *start2,Uchar *end2)$/;"	f	file:
lcp	toci.cpp	/^static long lcp(sauchar_t *start1,sauchar_t *start2,sauchar_t *end)$/;"	f	file:
leafcounts	streetyp.h	/^       *leafcounts;           \/\/ holds counts of the number of leafs in subtree$/;"	m	struct:Suffixtree
leaftab	streetyp.h	/^       *leaftab,              \/\/ stores the brother-references of the leafs$/;"	m	struct:Suffixtree
len	sparseSA.hpp	/^  long len; \/\/ length of match$/;"	m	struct:match_t
length	genDNA.py	/^length = sys.argv[1]$/;"	v
length	types.h	/^      Uint start, length;$/;"	m	struct:ListType
lineallocated	space.cpp	/^  Uint lineallocated;  \/\/ the linenumber where the$/;"	m	struct:Blockdescription	file:
linemapped	mapfile.cpp	/^static Uint linemapped[MAXMAPPEDFILES] = {0};       $/;"	v	file:
linklocstree	linkloc.cpp	/^void linklocstree(Suffixtree *stree,Location *outloc,Location *inloc)$/;"	f
linkrootchildren	construct.cpp	/^static void linkrootchildren(Suffixtree *stree)$/;"	f	file:
load_fasta	fasta.cpp	/^void load_fasta(string filename, string &S, vector<string> &descr, vector<long> &startpos) {$/;"	f
load_fasta	fasta.mod.cpp	/^void load_fasta(string filename, string &S, vector<string> &descr, vector<long> &startpos) {$/;"	f
loc2stringstree	streedbg.cpp	/^static void loc2stringstree(Suffixtree *stree,Stringtype *s,Location *loc)$/;"	f	file:
locstring	streetyp.h	/^  Stringtype locstring; \/\/ string represented by location$/;"	m	struct:Location
logN	sparseSA.hpp	/^  long logN; \/\/ ceil(log(N)) $/;"	m	struct:sparseSA
main	mummer.cpp	/^int main(int argc, char* argv[]) {$/;"	f
main	mummer.mod.cpp	/^int main(int argc, char* argv[]) {$/;"	f
main	mummer.pomp.cpp	/^int main(int argc, char* argv[]) {$/;"	f
main	mummer.s	/^main:$/;"	l
main	toci.cpp	/^int main(int argc, char *argv[])$/;"	f
makedepthtabstree	depthtab.cpp	/^void makedepthtabstree(ArrayUint *depthtab,Suffixtree *stree)$/;"	f
makeleaflist	dfs.cpp	/^Sint makeleaflist(Suffixtree *stree,ArrayUint *leaflist,Reference *start)$/;"	f
makeleastlengthtext	maxmatopt.cpp	/^static void makeleastlengthtext(char *spacefortext)$/;"	f	file:
mappedbytes	mapfile.cpp	/^            mappedbytes[MAXMAPPEDFILES] = {0};  \/\/ size of the memory map$/;"	v	file:
markpos	multidef.h	/^  ArrayPosition markpos;$/;"	m	struct:Multiseq
match_t	sparseSA.hpp	/^  match_t() { ref = 0; query = 0, len = 0; }$/;"	f	struct:match_t
match_t	sparseSA.hpp	/^  match_t(long r, long q, long l) { ref = r; query = q; len = l; }$/;"	f	struct:match_t
match_t	sparseSA.hpp	/^struct match_t {$/;"	s
matchnucleotidesonly	maxmatdef.h	/^       matchnucleotidesonly,    \/\/ match ONLY acgt's$/;"	m	struct:MMcallinfo
matchpath	findmaxmat.cpp	/^  ArrayPathinfo matchpath;        \/\/ path of br. nodes from ploc to maxloc$/;"	m	struct:Maxmatchinfo	file:
maxbranchdepth	streetyp.h	/^       maxbranchdepth,        \/\/ maximal depth of branching node$/;"	m	struct:Suffixtree
maxdesclength	maxmatdef.h	/^       maxdesclength,          \/\/ maximum length of a description$/;"	m	struct:Matchprocessinfo
maxdescrlen	sparseSA.hpp	/^  long maxdescrlen; \/\/ Maximum length of the sequence description, used for formatting.$/;"	m	struct:sparseSA
maxerrormsg	seterror.cpp	/^Sint maxerrormsg(void)$/;"	f
maxlength	multidef.h	/^       maxlength;        \/\/ maximal number of chars of description to be shown$/;"	m	struct:Showdescinfo
maxloc	findmaxmat.cpp	/^  Location maxloc;                \/\/ location of \\texttt{pmax}$/;"	m	struct:Maxmatchinfo	file:
maxset	streetyp.h	/^       *maxset;$/;"	m	struct:Suffixtree
memCount	sparseSA.cpp	/^long memCount = 0;$/;"	v
memCount	sparseSA.mod.cpp	/^long memCount = 0;$/;"	v
memCount	sparseSA.pomp.cpp	/^long memCount = 0;$/;"	v
memCount	sparseSA.s	/^memCount:$/;"	l
memoryptr	mapfile.cpp	/^static void *memoryptr[MAXMAPPEDFILES] = {NULL};$/;"	v	file:
messagespace	seterror.cpp	/^char *messagespace(void)$/;"	f
min_len	mummer.cpp	/^int min_len = 20;$/;"	v
min_len	mummer.mod.cpp	/^int min_len = 20;$/;"	v
min_len	mummer.pomp.cpp	/^int min_len = 20;$/;"	v
min_len	mummer.s	/^min_len:$/;"	l
min_len	sparseSA.cpp	/^  int min_len; \/\/ Minimum length of match.$/;"	m	struct:thread_data	file:
min_len	sparseSA.mod.cpp	/^  int min_len; \/\/ Minimum length of match.$/;"	m	struct:thread_data	file:
min_len	sparseSA.pomp.cpp	/^  int min_len; \/\/ Minimum length of match.$/;"	m	struct:thread_data	file:
minmatchlength	findmaxmat.cpp	/^       minmatchlength,            \/\/ min length of a match to be reported$/;"	m	struct:Maxmatchinfo	file:
minmatchlength	maxmatdef.h	/^  Uint minmatchlength,          \/\/ minimal length of a match to be reported$/;"	m	struct:MMcallinfo
minmatchlength	maxmatdef.h	/^  Uint minmatchlength,         \/\/ minimum length of a match$/;"	m	struct:Matchprocessinfo
mmaddspace	mapfile.cpp	/^static void mmaddspace(Uint space)$/;"	f	file:
mmcheckspaceleak	mapfile.cpp	/^void mmcheckspaceleak(void)$/;"	f
mmgetspacepeak	mapfile.cpp	/^Uint mmgetspacepeak(void)$/;"	f
mmsubtractspace	mapfile.cpp	/^static void mmsubtractspace(Uint space)$/;"	f	file:
mmwrapspace	mapfile.cpp	/^Sint mmwrapspace(void)$/;"	f
mum_t	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	g	file:
mum_t	mummer.mod.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	g	file:
mum_t	mummer.pomp.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	g	file:
mumcandtab	maxmatdef.h	/^  ArrayMUMcandidate mumcandtab;\/\/ a table containing MUM-candidates$/;"	m	struct:Matchprocessinfo
mumlength	mumcand.h	/^  Uint mumlength,    \/\/ length of the mum$/;"	m	struct:MUMcandidate
mumuniqueinquery	cleanMUMcand.cpp	/^Sint mumuniqueinquery(void *processinfo,$/;"	f
name	PapiCounter.h	/^    std::string name(int i)   { return names_[i]; };$/;"	f	class:PapiCounter
names_	PapiCounter.h	/^    std::vector<std::string> names_;$/;"	m	class:PapiCounter
nextfreeStrings	arraydef.h	/^  Uint stringbufferlength, nextfreeStrings, allocatedStrings;$/;"	m	struct:ArrayStrings
nextfreeblock	space.cpp	/^            nextfreeblock = 0,  \/\/ index of next free block$/;"	v	file:
nextfreebranch	streetyp.h	/^       *nextfreebranch,       \/\/ reference to next free base addr. in branchtab$/;"	m	struct:Suffixtree
nextfreebranchnum	streetyp.h	/^       nextfreebranchnum,     \/\/ the number of the next free branch node$/;"	m	struct:Suffixtree
nextfreeleafnum	streetyp.h	/^  Uint nextfreeleafnum,       \/\/ the number of the next leaf$/;"	m	struct:Suffixtree
nextfreeleafptr	streetyp.h	/^       *nextfreeleafptr,      \/\/ points to next free entry in leaftab$/;"	m	struct:Suffixtree
nextnode	streetyp.h	/^  Reference nextnode;   \/\/ reference to node the edge points to$/;"	m	struct:Location
nextnode	streetyp.h	/^  Reference nextnode;$/;"	m	struct:Simpleloc
nodecount	streetyp.h	/^       nodecount,$/;"	m	struct:Suffixtree
nonmaximal	streetyp.h	/^       *nonmaximal,           \/\/ bit table: if node with headposition \\(i\\) is $/;"	m	struct:Suffixtree
nucleotides_only	mummer.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
nucleotides_only	mummer.mod.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
nucleotides_only	mummer.pomp.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
nucleotides_only	mummer.s	/^nucleotides_only:$/;"	l
numEvents	PapiCounter.h	/^    int numEvents(){$/;"	f	class:Papi
numThreads	PapiCounter.h	/^    int numThreads() {return numThreads_;};$/;"	f	class:Papi
numThreads_	PapiCounter.h	/^    int numThreads_;$/;"	m	class:Papi
num_threads	mummer.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
num_threads	mummer.mod.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
num_threads	mummer.pomp.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
num_threads	mummer.s	/^num_threads:$/;"	l
number	PapiCounter.h	/^    int         number(int i) { return numbers_[i]; };$/;"	f	class:PapiCounter
numberofblocks	space.cpp	/^static Uint numberofblocks = 0, \/\/ numberofblocks$/;"	v	file:
numberofcells	space.cpp	/^       numberofcells;  \/\/ number of cells in the block$/;"	m	struct:Blockdescription	file:
numbers_	PapiCounter.h	/^    std::vector<int>         numbers_;$/;"	m	class:PapiCounter
numofqueryfiles	maxmatdef.h	/^       numofqueryfiles;         \/\/ number of query files$/;"	m	struct:MMcallinfo
numofsequences	multidef.h	/^       numofsequences,                 \/\/ the number of sequences$/;"	m	struct:Multiseq
occursinlist	procopt.cpp	/^static bool occursinlist(Uint i,int *list)$/;"	f	file:
onmaxpath	findmaxmat.cpp	/^  bool onmaxpath;$/;"	m	struct:Nodeinfo	file:
onsuccpath	streetyp.h	/^       onsuccpath,            \/\/ refers to node on success path of headnode$/;"	m	struct:Suffixtree
operator ()	sparseSA.cpp	/^struct by_ref { bool operator() (const match_t &a, const match_t &b) const { if(a.ref == b.ref) return a.len > b.len; else return a.ref < b.ref; }  };$/;"	f	struct:by_ref
operator ()	sparseSA.mod.cpp	/^struct by_ref { bool operator() (const match_t &a, const match_t &b) const { if(a.ref == b.ref) return a.len > b.len; else return a.ref < b.ref; }  };$/;"	f	struct:by_ref
operator ()	sparseSA.pomp.cpp	/^struct by_ref { bool operator() (const match_t &a, const match_t &b) const { if(a.ref == b.ref) return a.len > b.len; else return a.ref < b.ref; }  };$/;"	f	struct:by_ref
operator <	sparseSA.hpp	/^    bool operator < (item_t t) const { return idx < t.idx;  }$/;"	f	struct:vec_uchar::item_t
operator []	PapiCounter.h	/^    PapiCounter& operator[] (std::string &str) { return event(str); };$/;"	f	class:PapiCounterList
operator []	PapiCounter.h	/^    PapiCounter& operator[] (std::string str) { return event(str); };$/;"	f	class:PapiCounterList
operator []	sparseSA.hpp	/^ int operator[] (size_t idx) {$/;"	f	struct:vec_uchar
optname	optdesc.h	/^  char *optname,             \/\/ the option string, begins with -$/;"	m	struct:OptionDescription
optval	optdesc.h	/^  Uint optval;               \/\/ the unique number of an option$/;"	m	struct:OptionDescription
originalsequence	multidef.h	/^        *originalsequence;             \/\/ NULL or points to orig. sequence$/;"	m	struct:Multiseq
overallsequences	multiseq.cpp	/^Sint overallsequences(bool rcmode,Multiseq *multiseq,void *applyinfo,$/;"	f
papiFileFormat	PapiCounter.h	/^enum papiFileFormat {fileFormatMatlab, fileFormatPlain, fileFormatLaTeX};$/;"	g
papi_print_error	PapiCounter.h	/^void Papi::papi_print_error(int ierr){$/;"	f	class:Papi
parsemaxmatoptions	maxmatopt.cpp	/^Sint parsemaxmatoptions(MMcallinfo *mmcallinfo,int argc, char *argv[])$/;"	f
pos2pospair	multiseq.cpp	/^Sint pos2pospair(Multiseq *multiseq,PairUint *pos,Uint position)$/;"	f
position	maxmatdef.h	/^    Uint depth, position;$/;"	m	struct:suffix
prefix	maxmatdef.h	/^       prefix,                  \/\/ length of prefix for Direct Access Table$/;"	m	struct:MMcallinfo
prefix	maxmatdef.h	/^       prefix,                  \/\/ length of prefix for Direct Access Table$/;"	m	struct:Matchprocessinfo
previousnode	streetyp.h	/^  Bref previousnode;    \/\/ reference to previous node (which is branching)$/;"	m	struct:Location
printScreen	PapiCounter.h	/^void PapiCounter::printScreen(){$/;"	f	class:PapiCounter
printScreen	PapiCounter.h	/^void PapiCounterList::printScreen(){$/;"	f	class:PapiCounterList
printSubstring	mummer.cpp	/^bool printSubstring = false;$/;"	v
printSubstring	mummer.mod.cpp	/^bool printSubstring = false;$/;"	v
printSubstring	mummer.pomp.cpp	/^bool printSubstring = false;$/;"	v
printSubstring	mummer.s	/^printSubstring:$/;"	l
printSubstring	sparseSA.hpp	/^  bool printSubstring;$/;"	m	struct:sparseSA
print_length	mummer.cpp	/^bool print_length = false;$/;"	v
print_length	mummer.mod.cpp	/^bool print_length = false;$/;"	v
print_length	mummer.pomp.cpp	/^bool print_length = false;$/;"	v
print_length	mummer.s	/^print_length:$/;"	l
print_match	sparseSA.cpp	/^void sparseSA::print_match(match_t m) {$/;"	f	class:sparseSA
print_match	sparseSA.cpp	/^void sparseSA::print_match(match_t m_new, vector<match_t> &buf) {$/;"	f	class:sparseSA
print_match	sparseSA.cpp	/^void sparseSA::print_match(string meta, vector<match_t> &buf, bool rc) {$/;"	f	class:sparseSA
print_match	sparseSA.mod.cpp	/^void sparseSA::print_match(match_t m) {$/;"	f	class:sparseSA
print_match	sparseSA.mod.cpp	/^void sparseSA::print_match(match_t m_new, vector<match_t> &buf) {$/;"	f	class:sparseSA
print_match	sparseSA.mod.cpp	/^void sparseSA::print_match(string meta, vector<match_t> &buf, bool rc) {$/;"	f	class:sparseSA
print_match	sparseSA.pomp.cpp	/^void sparseSA::print_match(match_t m) {$/;"	f	class:sparseSA
print_match	sparseSA.pomp.cpp	/^void sparseSA::print_match(match_t m_new, vector<match_t> &buf) {$/;"	f	class:sparseSA
print_match	sparseSA.pomp.cpp	/^void sparseSA::print_match(string meta, vector<match_t> &buf, bool rc) {$/;"	f	class:sparseSA
processbranch1	findmaxmat.cpp	/^static bool processbranch1(Bref nodeptr,void *info)$/;"	f	file:
processbranch2	findmaxmat.cpp	/^static Sint processbranch2(\/*@unused@*\/ Bref nodeptr,void *info)$/;"	f	file:
processinfo	findmaxmat.cpp	/^  void *processinfo;            \/\/ first arg. when calling previous function$/;"	m	struct:Maxmatchinfo	file:
processleaf	findmaxmat.cpp	/^static Sint processleaf(Uint leafindex,\/*@unused@*\/ Bref lcpnode,void *info)$/;"	f	file:
processmatch	findmaxmat.cpp	/^  Processmatchfunction processmatch; \/\/ this function processes found match$/;"	m	struct:Maxmatchinfo	file:
procmaxmatches	procmaxmat.cpp	/^Sint procmaxmatches(MMcallinfo *mmcallinfo,Multiseq *subjectmultiseq)$/;"	f
procoption	procopt.cpp	/^Sint procoption(OptionDescription *opt,Uint numofopt,char *optstring)$/;"	f
program	maxmatdef.h	/^  char program[PATH_MAX+1],     \/\/ the path of the program$/;"	m	struct:MMcallinfo
query	findmaxmat.cpp	/^  Uchar *query,                   \/\/ the query string$/;"	m	struct:Maxmatchinfo	file:
query	sparseSA.hpp	/^  long query; \/\/ position in query$/;"	m	struct:match_t
query_arg	mummer.cpp	/^struct query_arg {$/;"	s	file:
query_arg	mummer.mod.cpp	/^struct query_arg {$/;"	s	file:
query_arg	mummer.pomp.cpp	/^struct query_arg {$/;"	s	file:
query_fasta	mummer.cpp	/^string query_fasta;$/;"	v
query_fasta	mummer.mod.cpp	/^string query_fasta;$/;"	v
query_fasta	mummer.pomp.cpp	/^string query_fasta;$/;"	v
query_fasta	mummer.s	/^query_fasta:$/;"	l
query_thread	mummer.cpp	/^void *query_thread(void *arg_) {$/;"	f
query_thread	mummer.mod.cpp	/^void *query_thread(void *arg_) {$/;"	f
query_thread	mummer.pomp.cpp	/^void *query_thread(void *arg_) {$/;"	f
query_threads	mummer.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
query_threads	mummer.mod.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
query_threads	mummer.pomp.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
query_threads	mummer.s	/^query_threads:$/;"	l
querycommondepth	findmaxmat.cpp	/^  Uint querycommondepth;$/;"	m	struct:Nodeinfo	file:
queryfilelist	maxmatdef.h	/^       queryfilelist[MAXNUMOFQUERYFILES][PATH_MAX+1]; $/;"	m	struct:MMcallinfo
querylen	findmaxmat.cpp	/^  Uint querylen,                  \/\/ length of the current query$/;"	m	struct:Maxmatchinfo	file:
querymultiseq	maxmatdef.h	/^           querymultiseq;      \/\/ the Multiseq record of the queries$/;"	m	struct:Matchprocessinfo
queryseq	mumcand.h	/^       queryseq,     \/\/ number of the query sequence$/;"	m	struct:MUMcandidate
queryseqnum	findmaxmat.cpp	/^       queryseqnum,               \/\/ number of query sequence$/;"	m	struct:Maxmatchinfo	file:
querystart	mumcand.h	/^       querystart;   \/\/ start position in the query sequence      $/;"	m	struct:MUMcandidate
querysuffix	findmaxmat.cpp	/^        *querysuffix;             \/\/ current suffix of query$/;"	m	struct:Maxmatchinfo	file:
r	qsufsort.c	/^   r,                           \/* number of symbols aggregated by transform.*\/$/;"	v	file:
radixStep	sparseSA.cpp	/^void sparseSA::radixStep(int *t_new, int *SA, long &bucketNr, long *BucketBegin, long l, long r, long h) {$/;"	f	class:sparseSA
radixStep	sparseSA.mod.cpp	/^void sparseSA::radixStep(int *t_new, int *SA, long &bucketNr, long *BucketBegin, long l, long r, long h) {$/;"	f	class:sparseSA
radixStep	sparseSA.pomp.cpp	/^void sparseSA::radixStep(int *t_new, int *SA, long &bucketNr, long *BucketBegin, long l, long r, long h) {$/;"	f	class:sparseSA
randint	genDNA.py	/^from random import randint$/;"	i
rb	sparseSA.hpp	/^  long depth, start, end, lb, rb;$/;"	m	struct:interval_t
rcsequence	multidef.h	/^        *rcsequence,                   \/\/ NULL or points to $/;"	m	struct:Multiseq
ref	sparseSA.hpp	/^  long ref; \/\/ position in reference sequence$/;"	m	struct:match_t
ref	streetyp.h	/^  Bref ref;$/;"	m	struct:Pathinfo
relposition	multidef.h	/^       relposition;  \/\/ the relative position of the sequence$/;"	m	struct:Seqinfo
remain	streetyp.h	/^       remain;          \/\/ number of remaining characters on edge$/;"	m	struct:Location
remain	streetyp.h	/^  Uint remain,$/;"	m	struct:Simpleloc
replaceblanks	multidef.h	/^       replaceblanks,    \/\/ replaceblanks by underscore$/;"	m	struct:Showdescinfo
rescan	construct.cpp	/^static void rescan (Suffixtree *stree)$/;"	f	file:
rescanstree	linkloc.cpp	/^void rescanstree(Suffixtree *stree,Location *loc,$/;"	f
reset	sparseSA.hpp	/^  void reset(long e) { start = 0; end = e; depth = 0; }$/;"	f	struct:interval_t
reseterror	seterror.cpp	/^void reseterror(void)$/;"	f
resize	sparseSA.hpp	/^  void resize(size_t N) { vec.resize(N); }$/;"	f	struct:vec_uchar
rev_comp	mummer.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
rev_comp	mummer.mod.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
rev_comp	mummer.pomp.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
rev_comp	mummer.s	/^rev_comp:$/;"	l
reverse_complement	fasta.cpp	/^void reverse_complement(string &seq_rc, bool nucleotides_only) {$/;"	f
reverse_complement	fasta.mod.cpp	/^void reverse_complement(string &seq_rc, bool nucleotides_only) {$/;"	f
reversecomplement	maxmatdef.h	/^       reversecomplement,       \/\/ compute matches on reverse strand$/;"	m	struct:MMcallinfo
reversecomplement	maxmatdef.h	/^       reversecomplement,      \/\/ compute reverse complement matches$/;"	m	struct:Matchprocessinfo
rootchildren	streetyp.h	/^       *rootchildren;         \/\/ references to successors of root$/;"	m	struct:Suffixtree
rootsucclocationsstree	access.cpp	/^void rootsucclocationsstree(Suffixtree *stree,ArraySimpleloc *ll)$/;"	f
sa	mummer.cpp	/^sparseSA *sa;$/;"	v
sa	mummer.mod.cpp	/^sparseSA *sa;$/;"	v
sa	mummer.pomp.cpp	/^sparseSA *sa;$/;"	v
sa	mummer.s	/^sa:$/;"	l
sa	sparseSA.cpp	/^  sparseSA *sa; \/\/ Suffix array + aux informaton$/;"	m	struct:thread_data	file:
sa	sparseSA.mod.cpp	/^  sparseSA *sa; \/\/ Suffix array + aux informaton$/;"	m	struct:thread_data	file:
sa	sparseSA.pomp.cpp	/^  sparseSA *sa; \/\/ Suffix array + aux informaton$/;"	m	struct:thread_data	file:
safestringcopy	safescpy.cpp	/^Sint safestringcopy(char *dest,char *source,Sint maxlen)$/;"	f
scanmultiplefastafile	maxmatinp.cpp	/^Sint scanmultiplefastafile (Multiseq *multiseq,$/;"	f
scanprefix	construct.cpp	/^static void scanprefix(Suffixtree *stree)$/;"	f	file:
scanprefixfromnodestree	scanpref.cpp	/^Uchar *scanprefixfromnodestree(Suffixtree *stree,Location *loc,Bref btptr,Uchar *left,Uchar *right,Uint rescanlength)$/;"	f
scanprefixstree	scanpref.cpp	/^Uchar *scanprefixstree(Suffixtree *stree,Location *outloc,$/;"	f
search	sparseSA.cpp	/^bool sparseSA::search(string &P, long &start, long &end) {$/;"	f	class:sparseSA
search	sparseSA.mod.cpp	/^bool sparseSA::search(string &P, long &start, long &end) {$/;"	f	class:sparseSA
search	sparseSA.pomp.cpp	/^bool sparseSA::search(string &P, long &start, long &end) {$/;"	f	class:sparseSA
secondtime	streetyp.h	/^  bool secondtime;$/;"	m	struct:DFSstate
select_sort_split	qsufsort.c	/^static void select_sort_split(int *p, int n) {$/;"	f	file:
sentinel	streetyp.h	/^         *sentinel;           \/\/ points to the position of the \\(\\$\\)-symbol$/;"	m	struct:Suffixtree
seq	genDNA.py	/^seq = []$/;"	v
seqlength	multidef.h	/^       seqlength,    \/\/ the length of the sequence$/;"	m	struct:Seqinfo
seqnum	multidef.h	/^  Uint seqnum,       \/\/ the sequence number in multiseq$/;"	m	struct:Seqinfo
seqstartpos	multidef.h	/^       seqstartpos,  \/\/ the position of the first character in multiseq.sequence$/;"	m	struct:Seqinfo
sequence	multidef.h	/^  Uchar *sequence,                     \/\/ the concatenated sequences$/;"	m	struct:Multiseq
set	sparseSA.hpp	/^  void set(size_t idx, int v) {$/;"	f	struct:vec_uchar
setBoth	mummer.cpp	/^bool setBoth = false;$/;"	v
setBoth	mummer.mod.cpp	/^bool setBoth = false;$/;"	v
setBoth	mummer.pomp.cpp	/^bool setBoth = false;$/;"	v
setBoth	mummer.s	/^setBoth:$/;"	l
setRevComp	mummer.cpp	/^bool setRevComp = false;$/;"	v
setRevComp	mummer.mod.cpp	/^bool setRevComp = false;$/;"	v
setRevComp	mummer.pomp.cpp	/^bool setRevComp = false;$/;"	v
setRevComp	mummer.s	/^setRevComp:$/;"	l
setatnewleaf	streetyp.h	/^  bool setatnewleaf;          \/\/ nil-reference is stored in new leaf$/;"	m	struct:Suffixtree
setdepthtab	depthtab.cpp	/^static void setdepthtab(ArrayUint *depthtab,Uint depth)$/;"	f	file:
seterror	seterror.cpp	/^void seterror(Sint code)$/;"	f
setlink	streetyp.h	/^       *setlink,              \/\/ address of a nil-reference$/;"	m	struct:Suffixtree
setmaxspace	space.cpp	/^static void setmaxspace(void)$/;"	f	file:
setup_	PapiCounter.h	/^    bool setup_;$/;"	m	class:Papi
showdepthtab	depthtab.cpp	/^void showdepthtab(ArrayUint *dt)$/;"	f
showexclude	procopt.cpp	/^void showexclude(OptionDescription *opt,Sint *excludetab,Uint len)$/;"	f
showlocation	streedbg.cpp	/^void showlocation(FILE *fp,Suffixtree *stree,Location *loc)$/;"	f
showmaximalmatch	procmaxmat.cpp	/^static Sint showmaximalmatch (void *info,$/;"	f	file:
showoptdesc	procopt.cpp	/^static void showoptdesc(FILE *fp,Uint indentlevel,char *desc)$/;"	f	file:
showoptions	procopt.cpp	/^void showoptions(FILE *outfp,char *program,OptionDescription *opt,$/;"	f
showoptionswithoutexclude	procopt.cpp	/^void showoptionswithoutexclude(FILE *outfp,char *program,$/;"	f
showpathstree	access.cpp	/^void showpathstree(Suffixtree *stree,Bref bnode,$/;"	f
showreversepositions	maxmatdef.h	/^       showreversepositions,    \/\/ give reverse pos. rel. to orig. string$/;"	m	struct:MMcallinfo
showreversepositions	maxmatdef.h	/^       showreversepositions,   \/\/ is option \\texttt{-c} on?$/;"	m	struct:Matchprocessinfo
showseqandmaximalmatch	procmaxmat.cpp	/^static Sint showseqandmaximalmatch (void *info,$/;"	f	file:
showsequencedescription	procmaxmat.cpp	/^static void showsequencedescription(Multiseq *multiseq, Uint maxdesclength,$/;"	f	file:
showsequenceheader	procmaxmat.cpp	/^static void showsequenceheader(Multiseq *multiseq,$/;"	f	file:
showsequencelengths	maxmatdef.h	/^       showsequencelengths,     \/\/ show length of sequences on header line$/;"	m	struct:MMcallinfo
showsequencelengths	maxmatdef.h	/^       showsequencelengths,    \/\/ is option \\texttt{-L} on?$/;"	m	struct:Matchprocessinfo
showstate	streedbg.cpp	/^void showstate(Suffixtree *stree)$/;"	f
showstree	streedbg.cpp	/^void showstree(Suffixtree *stree)$/;"	f
showstring	maxmatdef.h	/^  bool showstring,              \/\/ show the matching string$/;"	m	struct:MMcallinfo
showstring	maxmatdef.h	/^  bool showstring,             \/\/ is option \\texttt{-s} on?$/;"	m	struct:Matchprocessinfo
showsubtree	streedbg.cpp	/^static void showsubtree(Suffixtree *stree,Uint indent,Uint *btptr)$/;"	f	file:
showsymbol	streedbg.cpp	/^char *showsymbol(Uchar c)$/;"	f
showsymbolstree	streetyp.h	/^  char * (*showsymbolstree)(Uchar,Uchar *);$/;"	m	struct:Suffixtree
showtable	streedbg.cpp	/^void showtable(Suffixtree *stree,bool final)$/;"	f
showthesymbolstring	streedbg.cpp	/^void showthesymbolstring(FILE *fp,Uchar *tlast,Uchar *left,$/;"	f
showusage	maxmatopt.cpp	/^static void showusage(char *program,OptionDescription *options,$/;"	f	file:
simplefileOpen	mapfile.cpp	/^Sint simplefileOpen(char *filename,Uint *numofbytes)$/;"	f
size	sparseSA.hpp	/^  long size() { return end - start + 1; }$/;"	f	struct:interval_t
sizeofcells	space.cpp	/^  Uint sizeofcells,    \/\/ size of cells of the block$/;"	m	struct:Blockdescription	file:
skip	mummer.cpp	/^  int skip;$/;"	m	struct:query_arg	file:
skip	mummer.mod.cpp	/^  int skip;$/;"	m	struct:query_arg	file:
skip	mummer.pomp.cpp	/^  int skip;$/;"	m	struct:query_arg	file:
skip0	mummer.cpp	/^  int skip0;$/;"	m	struct:query_arg	file:
skip0	mummer.mod.cpp	/^  int skip0;$/;"	m	struct:query_arg	file:
skip0	mummer.pomp.cpp	/^  int skip0;$/;"	m	struct:query_arg	file:
skipprefix	multidef.h	/^  Uint skipprefix,       \/\/ always skip this number of prefixes$/;"	m	struct:Showdescinfo
smallnode	streetyp.h	/^       smallnode,             \/\/ number of small nodes$/;"	m	struct:Suffixtree
smallnotcompleted	streetyp.h	/^       smallnotcompleted,     \/\/ the number of small nodes in the current chain$/;"	m	struct:Suffixtree
sortMUMcandidates	cleanMUMcand.cpp	/^static void sortMUMcandidates(ArrayMUMcandidate *mumcand)$/;"	f	file:
sort_split	qsufsort.c	/^static void sort_split(int *p, int n)$/;"	f	file:
sort_split	qsufsort.s	/^sort_split:$/;"	l
spaceStrings	arraydef.h	/^  Stringtype *spaceStrings;$/;"	m	struct:ArrayStrings
spaceforbranchtab	construct.cpp	/^static void spaceforbranchtab(Suffixtree *stree)$/;"	f	file:
spacepeak	mapfile.cpp	/^            spacepeak = 0,                 \/\/ maximally mapped num of bytes$/;"	v	file:
spacepeak	space.cpp	/^            spacepeak = 0;      \/\/ maximally allocated num of bytes$/;"	v	file:
spaceptr	space.cpp	/^  void *spaceptr;      \/\/ ptr to the spaceblock$/;"	m	struct:Blockdescription	file:
sparseMult	mummer.cpp	/^int sparseMult=1;$/;"	v
sparseMult	mummer.mod.cpp	/^int sparseMult=1;$/;"	v
sparseMult	mummer.pomp.cpp	/^int sparseMult=1;$/;"	v
sparseMult	mummer.s	/^sparseMult:$/;"	l
sparseMult	sparseSA.hpp	/^  int sparseMult;$/;"	m	struct:sparseSA
sparseSA	sparseSA.cpp	/^sparseSA::sparseSA(string &R_, vector<string> &descr_, vector<long> &startpos_, bool __4column, long K_, bool suflink_, bool child_, int sparseMult_, bool printSubstring_) : $/;"	f	class:sparseSA
sparseSA	sparseSA.hpp	/^struct sparseSA {$/;"	s
sparseSA	sparseSA.mod.cpp	/^sparseSA::sparseSA(string &R_, vector<string> &descr_, vector<long> &startpos_, bool __4column, long K_, bool suflink_, bool child_, int sparseMult_, bool printSubstring_) : $/;"	f	class:sparseSA
sparseSA	sparseSA.pomp.cpp	/^sparseSA::sparseSA(string &R_, vector<string> &descr_, vector<long> &startpos_, bool __4column, long K_, bool suflink_, bool child_, int sparseMult_, bool printSubstring_) : $/;"	f	class:sparseSA
stack	streetyp.h	/^  ArrayBref stack;$/;"	m	struct:DFSstate
start	PapiCounter.h	/^void PapiCounter::start(){$/;"	f	class:PapiCounter
start	sparseSA.hpp	/^  long depth, start, end, lb, rb;$/;"	m	struct:interval_t
start	types.h	/^      Uint start, length;$/;"	m	struct:ListType
startCounters	PapiCounter.h	/^void Papi::startCounters(){$/;"	f	class:Papi
startdesc	multidef.h	/^  Uint *startdesc,                     \/\/ of length numofsequences + 1$/;"	m	struct:Multiseq
startpos	sparseSA.hpp	/^  vector<long> &startpos; \/\/ Lengths of concatenated sequences.$/;"	m	struct:sparseSA
stop	PapiCounter.h	/^void PapiCounter::stop(){$/;"	f	class:PapiCounter
stopCounters	PapiCounter.h	/^void Papi::stopCounters(){$/;"	f	class:Papi
storeMUMcandidate	procmaxmat.cpp	/^static Sint storeMUMcandidate (void *info, Uint matchlength, Uint subjectstart, Uint seqnum, Uint querystart)$/;"	f	file:
stree	findmaxmat.cpp	/^  Suffixtree *stree;              \/\/ reference to suffix tree of subject-seq$/;"	m	struct:Maxmatchinfo	file:
stree	maxmatdef.h	/^  Suffixtree stree;            \/\/ the suffix tree of the subject-sequence$/;"	m	struct:Matchprocessinfo
stringbuffer	arraydef.h	/^  Uchar *stringbuffer;$/;"	m	struct:ArrayStrings
stringbufferlength	arraydef.h	/^  Uint stringbufferlength, nextfreeStrings, allocatedStrings;$/;"	m	struct:ArrayStrings
subjectfile	maxmatdef.h	/^       subjectfile[PATH_MAX+1], \/\/ filename of the subject-sequence$/;"	m	struct:MMcallinfo
subjectmultiseq	maxmatdef.h	/^  Multiseq *subjectmultiseq,   \/\/ reference to multiseq of subject$/;"	m	struct:Matchprocessinfo
subtractspace	space.cpp	/^static void subtractspace(Uint space)$/;"	f	file:
succlocationsstree	access.cpp	/^void succlocationsstree(Suffixtree *stree,bool nosentinel,Simpleloc *loc,$/;"	f
suffix	maxmatdef.h	/^struct suffix$/;"	s
suffixlink	sparseSA.cpp	/^bool sparseSA::suffixlink(interval_t &m) {$/;"	f	class:sparseSA
suffixlink	sparseSA.mod.cpp	/^bool sparseSA::suffixlink(interval_t &m) {$/;"	f	class:sparseSA
suffixlink	sparseSA.pomp.cpp	/^bool sparseSA::suffixlink(interval_t &m) {$/;"	f	class:sparseSA
suffixlink	streetyp.h	/^  Bref suffixlink;          \/\/ the suffix link is always to a branching node$/;"	m	struct:Branchinfo
suffixsort	qsufsort.c	/^void suffixsort(int *x, int *p, int n, int k, int l)$/;"	f
suffixsort	qsufsort.s	/^suffixsort:$/;"	l
suflink	mummer.cpp	/^bool suflink = true;$/;"	v
suflink	mummer.mod.cpp	/^bool suflink = true;$/;"	v
suflink	mummer.pomp.cpp	/^bool suflink = true;$/;"	v
suflink	mummer.s	/^suflink:$/;"	l
sys	genDNA.py	/^import sys$/;"	i
table	maxmatdef.h	/^  Table table;                 \/\/ Table to quickly discard suffixes$/;"	m	struct:Matchprocessinfo
taillcp	construct.cpp	/^static Uint taillcp(Suffixtree *stree,Uchar *start1, Uchar *end1)$/;"	f	file:
tailptr	streetyp.h	/^         *tailptr;            \/\/ points to the tail$/;"	m	struct:Suffixtree
text	streetyp.h	/^  Uchar *text,               \/\/ points to the input string$/;"	m	struct:Suffixtree
textlen	streetyp.h	/^  Uint textlen,               \/\/ the length of the input string$/;"	m	struct:Suffixtree
textpos	streetyp.h	/^       textpos;  \/\/ these last two items are redundant and can be computed$/;"	m	struct:Simpleloc
thread_data	sparseSA.cpp	/^struct thread_data {$/;"	s	file:
thread_data	sparseSA.mod.cpp	/^struct thread_data {$/;"	s	file:
thread_data	sparseSA.pomp.cpp	/^struct thread_data {$/;"	s	file:
threads	PapiCounter.h	/^    int         threads()     { return Papi::instance()->numThreads(); };$/;"	f	class:PapiCounter
time	PapiCounter.h	/^    double      time()          { return vecMean(times_); };$/;"	f	class:PapiCounter
time	PapiCounter.h	/^    double      time(int tid)          { assert(tid<threads()); return times_[tid]; };$/;"	f	class:PapiCounter
time	PapiCounter.h	/^    double time(int tid){$/;"	f	class:Papi
timeVec_	PapiCounter.h	/^    std::vector<double> timeVec_;$/;"	m	class:Papi
times_	PapiCounter.h	/^    std::vector<double>      times_;$/;"	m	class:PapiCounter
toleaf	streetyp.h	/^  bool toleaf;$/;"	m	struct:Reference
top_down	sparseSA.cpp	/^bool sparseSA::top_down(char c, long i, long &start, long &end) {$/;"	f	class:sparseSA
top_down	sparseSA.mod.cpp	/^bool sparseSA::top_down(char c, long i, long &start, long &end) {$/;"	f	class:sparseSA
top_down	sparseSA.pomp.cpp	/^bool sparseSA::top_down(char c, long i, long &start, long &end) {$/;"	f	class:sparseSA
top_down_child	sparseSA.cpp	/^bool sparseSA::top_down_child(char c, interval_t &cur){$/;"	f	class:sparseSA
top_down_child	sparseSA.mod.cpp	/^bool sparseSA::top_down_child(char c, interval_t &cur){$/;"	f	class:sparseSA
top_down_child	sparseSA.pomp.cpp	/^bool sparseSA::top_down_child(char c, interval_t &cur){$/;"	f	class:sparseSA
top_down_faster	sparseSA.cpp	/^bool sparseSA::top_down_faster(char c, long i, long &start, long &end) {$/;"	f	class:sparseSA
top_down_faster	sparseSA.mod.cpp	/^bool sparseSA::top_down_faster(char c, long i, long &start, long &end) {$/;"	f	class:sparseSA
top_down_faster	sparseSA.pomp.cpp	/^bool sparseSA::top_down_faster(char c, long i, long &start, long &end) {$/;"	f	class:sparseSA
totallength	multidef.h	/^       totallength;                    \/\/ the total length of all sequences$/;"	m	struct:Multiseq
transform	qsufsort.c	/^static int transform(int *x, int *p, int n, int k, int l, int q)$/;"	f	file:
transform	qsufsort.s	/^transform:$/;"	l
traverse	sparseSA.cpp	/^void sparseSA::traverse(string &P, long prefix, interval_t &cur, int min_len) {$/;"	f	class:sparseSA
traverse	sparseSA.mod.cpp	/^void sparseSA::traverse(string &P, long prefix, interval_t &cur, int min_len) {$/;"	f	class:sparseSA
traverse	sparseSA.pomp.cpp	/^void sparseSA::traverse(string &P, long prefix, interval_t &cur, int min_len) {$/;"	f	class:sparseSA
traverse_faster	sparseSA.cpp	/^void sparseSA::traverse_faster(const string &P,const long prefix, interval_t &cur, int min_len){$/;"	f	class:sparseSA
traverse_faster	sparseSA.mod.cpp	/^void sparseSA::traverse_faster(const string &P,const long prefix, interval_t &cur, int min_len){$/;"	f	class:sparseSA
traverse_faster	sparseSA.pomp.cpp	/^void sparseSA::traverse_faster(const string &P,const long prefix, interval_t &cur, int min_len){$/;"	f	class:sparseSA
trim	fasta.cpp	/^void trim(string &line, long &start, long &end) {$/;"	f
trim	fasta.mod.cpp	/^void trim(string &line, long &start, long &end) {$/;"	f
type	mummer.cpp	/^mum_t type = MAM;$/;"	v
type	mummer.mod.cpp	/^mum_t type = MAM;$/;"	v
type	mummer.pomp.cpp	/^mum_t type = MAM;$/;"	v
type	mummer.s	/^type:$/;"	l
uint0	types.h	/^      Uint uint0, uint1, uint2;$/;"	m	struct:ThreeUint
uint0	types.h	/^    Uint uint0, uint1;$/;"	m	struct:PairUint
uint1	types.h	/^      Uint uint0, uint1, uint2;$/;"	m	struct:ThreeUint
uint1	types.h	/^    Uint uint0, uint1;$/;"	m	struct:PairUint
uint2	types.h	/^      Uint uint0, uint1, uint2;$/;"	m	struct:ThreeUint
untilfirstblank	multidef.h	/^       untilfirstblank;  \/\/ only show sequence until first blank$/;"	m	struct:Showdescinfo
update_group	qsufsort.c	/^static void update_group(int *pl, int *pm)$/;"	f	file:
usage	mummer.cpp	/^void usage(string prog) {$/;"	f
usage	mummer.mod.cpp	/^void usage(string prog) {$/;"	f
usage	mummer.pomp.cpp	/^void usage(string prog) {$/;"	f
val	sparseSA.hpp	/^    size_t idx; int val;$/;"	m	struct:vec_uchar::item_t
vec	sparseSA.hpp	/^  vector<unsigned char> vec;  \/\/ LCP values from 0-65534$/;"	m	struct:vec_uchar
vecMean	PapiCounter.h	/^T vecMean(std::vector<T> const &v){$/;"	f
vecSum	PapiCounter.h	/^T vecSum(std::vector<T> const &v){$/;"	f
vec_uchar	sparseSA.hpp	/^struct vec_uchar {$/;"	s
wccSequence	procmaxmat.cpp	/^static void wccSequence (Uchar *seq,$/;"	f	file:
wrapspace	space.cpp	/^void wrapspace(void)$/;"	f
writeToFile	PapiCounter.h	/^void PapiCounter::writeToFile(std::string const &runName, int eventID, std::ofstream &fid, papiFileFormat fileFormat){$/;"	f	class:PapiCounter
writeToFile	PapiCounter.h	/^void PapiCounterList::writeToFile(std::ofstream &fid, papiFileFormat fileFormat){$/;"	f	class:PapiCounterList
writeToFile	PapiCounter.h	/^void PapiCounterList::writeToFile(std::string fname, papiFileFormat fileFormat){$/;"	f	class:PapiCounterList
writeVecMatlab	PapiCounter.h	/^void writeVecMatlab(std::ofstream &fid, std::string name, TVec const &v){$/;"	f
