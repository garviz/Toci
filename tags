!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	procmaxmat.cpp	/^Match_t  * A = NULL;$/;"	v
ACCESSBRANCHBROTHER	streemac.h	26;"	d
ACCESSDEPTH	streemac.h	22;"	d
ACCESSFIRSTCHILD	streemac.h	25;"	d
ACCESSHEADPOS	streemac.h	23;"	d
ACCESSSUFFIXLINK	streemac.h	24;"	d
ADDAMOUNT	depthtab.cpp	17;"	d	file:
ADDFACTOR	construct.cpp	71;"	d	file:
ADDOPTION	optdesc.h	45;"	d
ALLOCSPACE	spacedef.h	70;"	d
ALLOCVIAFATAL	space.cpp	51;"	d	file:
ARGS_H	args.h	12;"	d
ARRAYDEF_H	arraydef.h	12;"	d
ASSIGNDEFAULTSHOWDESC	multidef.h	74;"	d
ASSIGNMAXMATCOMPLEMENT	procmaxmat.cpp	344;"	d	file:
ArrayCharacters	arraydef.h	/^typedef ArrayUchar ArrayCharacters;     \/\/ \\Typedef{ArrayCharacters}$/;"	t
ArrayPosition	arraydef.h	/^typedef ArrayUint  ArrayPosition;       \/\/ \\Typedef{ArrayPosition}$/;"	t
ArrayStrings	arraydef.h	/^struct ArrayStrings$/;"	s
BRADDR2NUM	streemac.h	60;"	d
Blockdescription	space.cpp	/^struct Blockdescription$/;"	s	file:
Branchinfo	streetyp.h	/^struct Branchinfo$/;"	s
Bref	streetyp.h	/^DECLAREARRAYSTRUCT(Bref);$/;"	v
Bref	streetyp.h	/^typedef Uint * Bref;    \/\/ \\Typedef{Bref}$/;"	t
Bref	types.h	/^typedef Uint * Bref;    $/;"	t
By_Q	procmaxmat.cpp	/^static int  By_Q (const void * A, const void * B)$/;"	f	file:
CHARDEF_H	chardef.h	12;"	d
CHECKADDR	streemac.h	66;"	d
CHECKARGNUM	args.h	28;"	d
CHECKARRAYSPACE	arraydef.h	63;"	d
CHECKARRAYSPACEMULTI	arraydef.h	81;"	d
CHECKIFLOCATIONISVALID	findmaxmat.cpp	134;"	d	file:
CHECKSTEP	construct.cpp	696;"	d	file:
CHECKSTEP	construct.cpp	811;"	d	file:
CHECKSTEP	findmaxmat.cpp	41;"	d	file:
CHECKTEXTLEN	construct.cpp	26;"	d	file:
CLEARBITTAB	intbits.h	74;"	d
COMPLETELARGEFIRST	construct.cpp	692;"	d	file:
COMPLETELARGEFIRST	construct.cpp	808;"	d	file:
COMPLETELARGESECOND	construct.cpp	693;"	d	file:
COMPLETELARGESECOND	construct.cpp	809;"	d	file:
CONSTRUCTSTREE	streemac.h	33;"	d
COPYMULTISEQ	multiseq.cpp	51;"	d	file:
CREATEMEMORYMAP	spacedef.h	96;"	d
CREATEMEMORYMAPFORFILEDESC	spacedef.h	99;"	d
DECLAREARRAYSTRUCT	arraydef.h	41;"	d
DECLAREEXTRA	construct.cpp	680;"	d	file:
DECLAREEXTRA	construct.cpp	807;"	d	file:
DECLAREEXTRA	findmaxmat.cpp	29;"	d	file:
DEFAULTMINUNIQUEMATCHLEN	maxmatopt.cpp	33;"	d	file:
DELETEMEMORYMAP	spacedef.h	102;"	d
DESCRIPTIONLENGTH	multidef.h	66;"	d
DESCRIPTIONPTR	multidef.h	63;"	d
DESCRIPTIONSTARTDESC	multidef.h	60;"	d
DFSstate	streetyp.h	/^struct DFSstate$/;"	s
DIV2	types.h	40;"	d
DIVBYSMALLINTS	streehuge.h	33;"	d
DIVWORDSIZE	intbits.h	47;"	d
DYNAMICSTRDUP	spacedef.h	93;"	d
ERROR0	errordef.h	60;"	d
ERROR1	errordef.h	63;"	d
ERROR2	errordef.h	66;"	d
ERROR3	errordef.h	69;"	d
ERROR4	errordef.h	72;"	d
ERROR5	errordef.h	75;"	d
ERRORDEF_H	errordef.h	12;"	d
EXCEPTFIRSTBIT	intbits.h	41;"	d
EXCEPTFIRSTTHREEBITS	intbits.h	45;"	d
EXCEPTFIRSTTWOBITS	intbits.h	43;"	d
FASTASEPARATOR	multidef.h	52;"	d
FINALPROGRESS	construct.cpp	714;"	d	file:
FINALPROGRESS	construct.cpp	812;"	d	file:
FIRSTBIT	intbits.h	29;"	d
FIRSTTWOBITS	intbits.h	39;"	d
FOLLOWSUFFIXLINK	streeacc.h	157;"	d
FREEARRAY	arraydef.h	116;"	d
FREESPACE	spacedef.h	80;"	d
Filter_Matches	procmaxmat.cpp	/^static void  Filter_Matches (Match_t * A, int & N)$/;"	f	file:
Findmatchfunction	procmaxmat.cpp	/^typedef Sint (*Findmatchfunction)(Suffixtree *,$/;"	t	file:
GENERROR	errordef.h	45;"	d
GETBOTH	streeacc.h	42;"	d
GETBRANCHINDEX	streehuge.h	56;"	d
GETBROTHER	streehuge.h	63;"	d
GETCHAINEND	streehuge.h	85;"	d
GETCHILD	streehuge.h	62;"	d
GETDEPTH	streehuge.h	65;"	d
GETDEPTHAFTERHEADPOS	streeacc.h	108;"	d
GETDISTANCE	streehuge.h	64;"	d
GETHEADPOS	streehuge.h	66;"	d
GETHEADPOSAFTERDEPTH	streeacc.h	123;"	d
GETLEAFINDEX	streehuge.h	55;"	d
GETNEXTFREEINARRAY	arraydef.h	98;"	d
GETONLYDEPTH	streeacc.h	90;"	d
GETONLYHEADPOS	streeacc.h	72;"	d
GETSUFFIXLINK	streehuge.h	67;"	d
Good	procmaxmat.cpp	/^   unsigned int  Good : 1;$/;"	m	struct:Match_t	file:
HIGHESTVISIBLE	visible.h	34;"	d
INITARRAY	arraydef.h	52;"	d
INITBITTAB	intbits.h	59;"	d
INTBITS_H	intbits.h	12;"	d
INTWORDSIZE	intbits.h	27;"	d
INVISIBLE	visible.h	40;"	d
INVISIBLECHAR	visible.h	54;"	d
ISBITSET	intbits.h	31;"	d
ISBRANCHUSED	streedbg.cpp	22;"	d	file:
ISIBITSET	intbits.h	103;"	d
ISLARGE	streehuge.h	50;"	d
ISLEAF	streehuge.h	49;"	d
ISLEAFUSED	streedbg.cpp	19;"	d	file:
ISNOTSPECIAL	chardef.h	26;"	d
ISSET	optdesc.h	55;"	d
ISSPECIAL	chardef.h	25;"	d
ITHBIT	intbits.h	33;"	d
LARGEINTS	streehuge.h	31;"	d
LARGESTCHARINDEX	streehuge.h	96;"	d
LARGESTCHARINDEX	streehuge.h	98;"	d
LEADLEVEL	streeacc.h	201;"	d
LEAFADDR2NUM	streemac.h	61;"	d
LEAFBIT	streehuge.h	35;"	d
LEAFBROTHERVAL	streehuge.h	82;"	d
LEASTSHOWPROGRESS	construct.cpp	677;"	d	file:
LEASTSHOWPROGRESS	findmaxmat.cpp	26;"	d	file:
LOGWORDSIZE	types.h	35;"	d
LOWESTVISIBLE	visible.h	28;"	d
Leafinfo	streetyp.h	/^typedef Reference Leafinfo;  \/\/ \\Typedef{Leafinfo}$/;"	t
Len	procmaxmat.cpp	/^   long int  R, Q, Len;$/;"	m	struct:Match_t	file:
ListType	types.h	/^struct ListType$/;"	s
Location	streetyp.h	/^struct Location$/;"	s
Lref	streetyp.h	/^typedef Uint * Lref;    \/\/ \\Typedef{Lref}$/;"	t
Lref	types.h	/^typedef Uint * Lref;  $/;"	t
MAKEBRANCHADDR	streehuge.h	86;"	d
MAKELARGE	streehuge.h	52;"	d
MAKELARGELEAF	streehuge.h	53;"	d
MAKELEAF	streehuge.h	51;"	d
MAX	minmax.h	22;"	d
MAXDISTANCE	streehuge.h	39;"	d
MAXERRORMSG	seterror.cpp	27;"	d	file:
MAXINDEX	streehuge.h	38;"	d
MAXMAPPEDFILES	mapfile.cpp	25;"	d	file:
MAXMATDEF_H	maxmatdef.h	12;"	d
MAXNUMOFQUERYFILES	maxmatdef.h	42;"	d
MAXTEXTLEN	streehuge.h	60;"	d
MIN	minmax.h	26;"	d
MINEXTRA	construct.cpp	72;"	d	file:
MINMAX_H	minmax.h	12;"	d
MMREPLACEMENTCHARQUERY	maxmatdef.h	36;"	d
MMREPLACEMENTCHARSUBJECT	maxmatdef.h	35;"	d
MMcallinfo	maxmatdef.h	/^struct MMcallinfo$/;"	s
MODWORDSIZE	intbits.h	49;"	d
MULTBYSMALLINTS	streehuge.h	32;"	d
MULTIDEF_H	multidef.h	12;"	d
MULWORDSIZE	intbits.h	51;"	d
MUMCAND_H	mumcand.h	12;"	d
MUMcandidate	mumcand.h	/^DECLAREARRAYSTRUCT(MUMcandidate);$/;"	v
MUMcandidate	mumcand.h	/^struct MUMcandidate$/;"	s
Match_t	procmaxmat.cpp	/^struct  Match_t$/;"	s	file:
Matchprocessinfo	maxmatdef.h	/^struct Matchprocessinfo$/;"	s
Maxmatchinfo	findmaxmat.cpp	/^struct Maxmatchinfo$/;"	s	file:
Multiseq	multidef.h	/^struct Multiseq$/;"	s
N	procmaxmat.cpp	/^long int  N = 0, Size = 500;$/;"	v
NEWLINE	multiseq.cpp	39;"	d	file:
NEXTNODE	streeacc.h	139;"	d
NILBIT	streehuge.h	37;"	d
NILPTR	streehuge.h	58;"	d
NOTSUPPOSED	errordef.h	110;"	d
NOTSUPPOSEDTOBENULL	errordef.h	120;"	d
NUMOFCALLS	construct.cpp	678;"	d	file:
NUMOFCALLS	findmaxmat.cpp	27;"	d	file:
NUMOFOPTIONS	maxmatopt.cpp	/^  NUMOFOPTIONS$/;"	e	enum:__anon1	file:
Nodeinfo	findmaxmat.cpp	/^DECLAREARRAYSTRUCT(Nodeinfo);$/;"	v
Nodeinfo	findmaxmat.cpp	/^struct Nodeinfo$/;"	s	file:
OPTCOMPUTEBOTHDIRECTIONS	maxmatopt.cpp	/^  OPTCOMPUTEBOTHDIRECTIONS,$/;"	e	enum:__anon1	file:
OPTDESC_H	optdesc.h	12;"	d
OPTFOURCOLUMN	maxmatopt.cpp	/^  OPTFOURCOLUMN,$/;"	e	enum:__anon1	file:
OPTH	maxmatopt.cpp	/^  OPTH,$/;"	e	enum:__anon1	file:
OPTHELP	maxmatopt.cpp	/^  OPTHELP,$/;"	e	enum:__anon1	file:
OPTION	optdesc.h	32;"	d
OPTIONEXCLUDE	optdesc.h	128;"	d
OPTIONIMPLY	optdesc.h	75;"	d
OPTIONIMPLYEITHER2	optdesc.h	83;"	d
OPTIONIMPLYEITHER3	optdesc.h	94;"	d
OPTIONIMPLYEITHER4	optdesc.h	108;"	d
OPTIONMANDATORY	optdesc.h	62;"	d
OPTLEASTLENGTH	maxmatopt.cpp	/^  OPTLEASTLENGTH,$/;"	e	enum:__anon1	file:
OPTMATCHNUCLEOTIDESONLY	maxmatopt.cpp	/^  OPTMATCHNUCLEOTIDESONLY,$/;"	e	enum:__anon1	file:
OPTMAXMATCH	maxmatopt.cpp	/^  OPTMAXMATCH,$/;"	e	enum:__anon1	file:
OPTMUM	maxmatopt.cpp	/^  OPTMUM = 0,$/;"	e	enum:__anon1	file:
OPTMUMCAND	maxmatopt.cpp	/^  OPTMUMCAND,$/;"	e	enum:__anon1	file:
OPTMUMREF	maxmatopt.cpp	/^  OPTMUMREF,$/;"	e	enum:__anon1	file:
OPTONLYREVERSECOMPLEMENT	maxmatopt.cpp	/^  OPTONLYREVERSECOMPLEMENT,$/;"	e	enum:__anon1	file:
OPTSHOWREVERSEPOSITIONS	maxmatopt.cpp	/^  OPTSHOWREVERSEPOSITIONS,$/;"	e	enum:__anon1	file:
OPTSHOWSEQUENCELENGTHS	maxmatopt.cpp	/^  OPTSHOWSEQUENCELENGTHS,$/;"	e	enum:__anon1	file:
OPTSHOWSTRING	maxmatopt.cpp	/^  OPTSHOWSTRING,$/;"	e	enum:__anon1	file:
OPTTABLE	maxmatopt.cpp	/^  OPTTABLE,$/;"	e	enum:__anon1	file:
OptionDescription	optdesc.h	/^struct OptionDescription$/;"	s
Optionnumber	maxmatopt.cpp	/^} Optionnumber;$/;"	t	typeref:enum:__anon1	file:
PARSEFLOATARG	args.h	53;"	d
PARSEINTARG	args.h	40;"	d
PROCESSALL	streedbg.cpp	24;"	d	file:
PROCESSBRANCH1	dfs.cpp	135;"	d	file:
PROCESSBRANCH1	dfs.cpp	137;"	d	file:
PROCESSBRANCH1	dfs.cpp	59;"	d	file:
PROCESSBRANCH2	dfs.cpp	136;"	d	file:
PROCESSBRANCH2	dfs.cpp	138;"	d	file:
PROCESSBRANCH2	dfs.cpp	60;"	d	file:
PROCESSHEAD	construct.cpp	694;"	d	file:
PROCESSHEAD	construct.cpp	810;"	d	file:
PROCESSREALMUMS	procmaxmat.cpp	324;"	d	file:
PROTODEF_H	protodef.h	10;"	d
PairUint	arraydef.h	/^DECLAREARRAYSTRUCT(PairUint);$/;"	v
PairUint	types.h	/^struct PairUint$/;"	s
Pathinfo	streetyp.h	/^DECLAREARRAYSTRUCT(Pathinfo);$/;"	v
Pathinfo	streetyp.h	/^struct Pathinfo$/;"	s
Process_Matches	procmaxmat.cpp	/^static void  Process_Matches (Match_t * A, int N) \/\/  Process matches  A [1 .. N].$/;"	f	file:
Processmatchfunction	maxmatdef.h	/^typedef Sint (*Processmatchfunction)$/;"	t
Q	procmaxmat.cpp	/^   long int  R, Q, Len;$/;"	m	struct:Match_t	file:
Qsortcomparefunction	types.h	/^typedef int (*Qsortcomparefunction)(const void *,const void *);$/;"	t
R	procmaxmat.cpp	/^   long int  R, Q, Len;$/;"	m	struct:Match_t	file:
RECALLBRANCHADDRESS	streeacc.h	189;"	d
RECALLLEAFADDRESS	streeacc.h	187;"	d
RECALLNEWLEAFADDRESS	streeacc.h	185;"	d
RECALLSUCC	streeacc.h	177;"	d
ROOT	streemac.h	45;"	d
ROOTLOCATION	streemac.h	52;"	d
Reference	streetyp.h	/^struct Reference$/;"	s
SECONDBIT	intbits.h	35;"	d
SEPARATOR	chardef.h	22;"	d
SETBRANCHNODEOFFSET	streehuge.h	87;"	d
SETBRANCHUSED	streedbg.cpp	21;"	d	file:
SETBROTHER	streehuge.h	69;"	d
SETCHILD	streehuge.h	68;"	d
SETCURRENT	dfs.cpp	15;"	d	file:
SETDEPTHHEADPOS	streehuge.h	73;"	d
SETDISTANCE	streehuge.h	71;"	d
SETIBIT	intbits.h	89;"	d
SETLEAFBROTHER	streehuge.h	83;"	d
SETLEAFUSED	streedbg.cpp	18;"	d	file:
SETMAXBRANCHDEPTH	streeacc.h	194;"	d
SETNEWCHILD	streehuge.h	76;"	d
SETNEWCHILDBROTHER	streehuge.h	77;"	d
SETNILBIT	streeacc.h	192;"	d
SETSUFFIXLINK	streehuge.h	80;"	d
SETVAL	streeacc.h	18;"	d
SHOWBOOL	types.h	33;"	d
SHOWCHAR	visible.h	76;"	d
SHOWCHARFP	visible.h	62;"	d
SHOWINDEX	streeacc.h	204;"	d
SHOWREF	streedbg.cpp	511;"	d	file:
SHOWVAL	streeacc.h	17;"	d
SIMPLESTANDARDMESSAGE	errordef.h	101;"	d
SMALLBIT	streehuge.h	36;"	d
SMALLINTS	streehuge.h	30;"	d
SPACEDEF_H	spacedef.h	12;"	d
STANDARDMESSAGE	errordef.h	97;"	d
STARTFACTOR	construct.cpp	68;"	d	file:
STOREINARRAY	arraydef.h	108;"	d
STORESTARTDESC	maxmatinp.cpp	37;"	d	file:
STORESTARTDESC	multiseq.cpp	57;"	d	file:
STREEACC_H	streeacc.h	10;"	d
STREEDEF_H	streedef.h	10;"	d
STREEHUGE_H	streehuge.h	16;"	d
STREEMAC_H	streemac.h	10;"	d
STREETYP_H	streetyp.h	10;"	d
SYMBOL	symboldef.h	/^typedef Uchar SYMBOL;$/;"	t
SYMBOL	symboldef.h	/^typedef Uint SYMBOL;$/;"	t
SYMBOL	symboldef.h	/^typedef Ushort SYMBOL;$/;"	t
SYMBOLBYTES	symboldef.h	13;"	d
SYMBOLDEF_H	symboldef.h	10;"	d
Safe_malloc	procmaxmat.cpp	/^static void *  Safe_malloc  (size_t Len)$/;"	f	file:
Safe_realloc	procmaxmat.cpp	/^static void *  Safe_realloc  (void * Q, size_t Len)$/;"	f	file:
Seqinfo	multidef.h	/^struct Seqinfo$/;"	s
Showdescinfo	multidef.h	/^struct Showdescinfo$/;"	s
Simpleloc	streetyp.h	/^DECLAREARRAYSTRUCT(Simpleloc);$/;"	v
Simpleloc	streetyp.h	/^struct Simpleloc$/;"	s
Sint	arraydef.h	/^DECLAREARRAYSTRUCT(Sint);$/;"	v
Sint	types.h	/^typedef signed long Sint;$/;"	t
Size	procmaxmat.cpp	/^long int  N = 0, Size = 500;$/;"	v
Stringtype	types.h	/^typedef ListType Stringtype;$/;"	t
Suffixtree	streetyp.h	/^struct Suffixtree$/;"	s
THIRDBIT	intbits.h	37;"	d
TYPES_H	types.h	20;"	d
Tentative	procmaxmat.cpp	/^   unsigned int  Tentative : 1;$/;"	m	struct:Match_t	file:
ThreeUint	arraydef.h	/^DECLAREARRAYSTRUCT(ThreeUint);$/;"	v
ThreeUint	types.h	/^struct ThreeUint$/;"	s
UNDEFCHAR	chardef.h	24;"	d
UNDEFFILESEP	multidef.h	85;"	d
UNDEFINEDREFERENCE	streehuge.h	59;"	d
UNDEFNUMOFDBSEQ	multiseq.cpp	45;"	d	file:
UNSETIBIT	intbits.h	96;"	d
USAGEOUT	errordef.h	86;"	d
Uchar	types.h	/^typedef unsigned char Uchar;$/;"	t
Uint	arraydef.h	/^DECLAREARRAYSTRUCT(Uint);$/;"	v
Uint	types.h	/^typedef unsigned long Uint;$/;"	t
UintConst	types.h	/^typedef const unsigned long UintConst;$/;"	t
Ushort	arraydef.h	/^DECLAREARRAYSTRUCT(Ushort);$/;"	v
Ushort	types.h	/^typedef unsigned short Ushort;$/;"	t
VALIDINIT	construct.cpp	24;"	d	file:
VISIBLECHAR	visible.h	48;"	d
VISIBLE_H	visible.h	13;"	d
WILDCARD	chardef.h	23;"	d
activeblocks	space.cpp	/^void activeblocks(void)$/;"	f
addoption	procopt.cpp	/^Sint addoption(OptionDescription *options,Uint numofoptions,$/;"	f
address	streetyp.h	/^  Uint *address;$/;"	m	struct:Reference
addspace	space.cpp	/^static void addspace(Uint space)$/;"	f	file:
allocandusespaceviaptr	space.cpp	/^\/*@notnull@*\/ void *allocandusespaceviaptr(char *file,Uint line, $/;"	f
allocatedStrings	arraydef.h	/^  Uint stringbufferlength, nextfreeStrings, allocatedStrings;$/;"	m	struct:ArrayStrings
alphabet	streetyp.h	/^  Uchar *alphabet;$/;"	m	struct:Suffixtree
alphasize	streetyp.h	/^       alphasize,             \/\/ the number of different characters in t$/;"	m	struct:Suffixtree
blocks	space.cpp	/^\/*@null@*\/ static Blockdescription *blocks = NULL;$/;"	v	file:
branchbrother	streetyp.h	/^            branchbrother;  \/\/ the reference to the right brother; $/;"	m	struct:Branchinfo
branchnodeoffset	streetyp.h	/^       branchnodeoffset,      \/\/ number of leafs in tree$/;"	m	struct:Suffixtree
branchtab	streetyp.h	/^       *branchtab,            \/\/ table TBranch$/;"	m	struct:Suffixtree
chainstart	streetyp.h	/^       *chainstart,           \/\/ address of the node, current chains starts at$/;"	m	struct:Suffixtree
checkdoubleexclude	procopt.cpp	/^int checkdoubleexclude(Uint numofopts,OptionDescription *opt,$/;"	f
checkexclude	procopt.cpp	/^int checkexclude(OptionDescription *opt,Sint *excludetab,Uint len)$/;"	f
checkiflocationisMUMcand	findmumcand.cpp	/^static Sint checkiflocationisMUMcand (Location *loc,$/;"	f	file:
checklocation	streedbg.cpp	/^void checklocation(Suffixtree *stree,Location *loc)$/;"	f
checkspaceleak	space.cpp	/^void checkspaceleak(void)$/;"	f
checkstree	streedbg.cpp	/^void checkstree(Suffixtree *stree)$/;"	f
cmaxmatch	maxmatdef.h	/^       cmaxmatch,               \/\/ compute all maximal matches$/;"	m	struct:MMcallinfo
cmum	maxmatdef.h	/^       cmum,                   \/\/ compute MUMs$/;"	m	struct:Matchprocessinfo
cmum	maxmatdef.h	/^       cmum;                    \/\/ compute real matches unique in both sequences$/;"	m	struct:MMcallinfo
cmumcand	maxmatdef.h	/^       cmumcand,                \/\/ compute reference-unique maximal matches$/;"	m	struct:MMcallinfo
cmumcand	maxmatdef.h	/^       cmumcand,               \/\/ compute MUM candidates$/;"	m	struct:Matchprocessinfo
commondepthstack	findmaxmat.cpp	/^  ArrayNodeinfo commondepthstack; \/\/ stack to store depth values$/;"	m	struct:Maxmatchinfo	file:
compareMUMcandidates	cleanMUMcand.cpp	/^static Sint compareMUMcandidates(MUMcandidate *p,MUMcandidate *q)$/;"	f	file:
comparelocs	streedbg.cpp	/^static Sint comparelocs(Suffixtree *stree,Location *loc1,Location *loc2)$/;"	f	file:
completelarge	construct.cpp	/^static void completelarge(Suffixtree *stree)$/;"	f	file:
constructprogressstree	construct.cpp	/^Sint constructprogressstree(Suffixtree *stree,Uchar *text,Uint textlen,void (*progress)(Uint,void *),void (*finalprogress)(void *),void *info)$/;"	f
counter	prefix.hpp	/^        int counter;$/;"	m	class:prefix
createTable	distribute.cpp	/^void createTable(Suffixtree *stree, sparsetable<Uint*> &table, Uint wordsize) $/;"	f
creatememorymap	mapfile.cpp	/^\/*@null@*\/ void *creatememorymap(char *file,Uint line,char *filename,bool writemap,Uint *numofbytes)$/;"	f
creatememorymapforfiledesc	mapfile.cpp	/^\/*@null@*\/ void *creatememorymapforfiledesc(char *file,Uint line,Sint fd,bool writemap,Uint $/;"	f
currentbranchtabsize	streetyp.h	/^       currentbranchtabsize,  \/\/ current number of cells in branchtab$/;"	m	struct:Suffixtree
currentdepth	streetyp.h	/^       currentdepth,          \/\/ depth of the new branch node$/;"	m	struct:Suffixtree
currentisrcmatch	maxmatdef.h	/^       currentisrcmatch;       \/\/ true iff currently rc-matches are computed$/;"	m	struct:Matchprocessinfo
currentquerylen	maxmatdef.h	/^       currentquerylen;        \/\/ length of the current query sequence$/;"	m	struct:Matchprocessinfo
currentspace	mapfile.cpp	/^static Uint currentspace = 0,              \/\/ currently mapped num of bytes$/;"	v	file:
currentspace	space.cpp	/^            currentspace = 0,   \/\/ currently allocated num of bytes$/;"	v	file:
dbstart	mumcand.h	/^       dbstart,      \/\/ start position in the subject-sequence$/;"	m	struct:MUMcandidate
declared	optdesc.h	/^       declared;             \/\/ is the option declared by$/;"	m	struct:OptionDescription
defined	multidef.h	/^  bool defined,          \/\/ show a description$/;"	m	struct:Showdescinfo
deletememorymap	mapfile.cpp	/^Sint deletememorymap(char *file,Uint line,void *mappedfile)$/;"	f
depth	streetyp.h	/^       depth;               \/\/ the depth of the branching node$/;"	m	struct:Branchinfo
depth	streetyp.h	/^  Uint depth, headposition;$/;"	m	struct:Pathinfo
depthfirststree	dfs.cpp	/^Sint depthfirststree(Suffixtree *stree,Reference *startnode,$/;"	f
depthofpreviousmaxloc	findmaxmat.cpp	/^       depthofpreviousmaxloc;     \/\/ the depth of the previous maxloc$/;"	m	struct:Maxmatchinfo	file:
description	optdesc.h	/^       *description;         \/\/ help text describing purpose of option$/;"	m	struct:OptionDescription
descspace	multidef.h	/^  ArrayCharacters descspace;           \/\/ the space for the descriptions$/;"	m	struct:Multiseq
dynamicstrdup	space.cpp	/^\/*@notnull@*\/ char *dynamicstrdup(char *file,Uint line,char *source)$/;"	f
edgelen	streetyp.h	/^  Uint edgelen,         \/\/ length of edge$/;"	m	struct:Location
encoding	distribute.cpp	/^Uint encoding(Uchar *example, Uint wordsize) $/;"	f
enumeratemaxmatches	findmaxmat.cpp	/^static Sint enumeratemaxmatches (Maxmatchinfo *maxmatchinfo,$/;"	f	file:
enumlocations	streedbg.cpp	/^void enumlocations(Suffixtree *stree,$/;"	f
enumlocationssubtree	streedbg.cpp	/^static void enumlocationssubtree(Suffixtree *stree,Uint *btptr,$/;"	f	file:
errorcode	seterror.cpp	/^static Sint errorcode = 0;$/;"	v	file:
errormessage	seterror.cpp	/^static char errormessage[MAXERRORMSG+1];$/;"	v	file:
extractsubtree	streedbg.cpp	/^void extractsubtree(Suffixtree *stree,Uint *btptr,sparsetable<Uint> &tNodes)$/;"	f
fileallocated	space.cpp	/^  char *fileallocated; \/\/ the filenames where the block was allocated$/;"	m	struct:Blockdescription	file:
filemapped	mapfile.cpp	/^static char *filemapped[MAXMAPPEDFILES] = {NULL};  $/;"	v	file:
findmaxmatches	findmaxmat.cpp	/^Sint findmaxmatches(Suffixtree *stree,$/;"	f
findmaxmatchesonbothstrands	procmaxmat.cpp	/^static Sint findmaxmatchesonbothstrands(void *info,Uint seqnum,$/;"	f	file:
findmumcandidates	findmumcand.cpp	/^Sint findmumcandidates(Suffixtree *stree,$/;"	f
findprefixpathfromnodestree	scanpref.cpp	/^\/*@null@*\/Uchar *findprefixpathfromnodestree(Suffixtree *stree,$/;"	f
findprefixpathstree	scanpref.cpp	/^\/*@null@*\/ Uchar *findprefixpathstree(Suffixtree *stree,$/;"	f
firstchild	streetyp.h	/^  Reference firstchild,     \/\/ the reference to the first child$/;"	m	struct:Branchinfo
firstnotallocated	streetyp.h	/^       *firstnotallocated,    \/\/ refers to the last address, such that at$/;"	m	struct:Suffixtree
firstptr	streetyp.h	/^  Uchar *firstptr;     \/\/ pointer to first character of edge label$/;"	m	struct:Location
forward	maxmatdef.h	/^       forward,                 \/\/ compute matches on forward strand$/;"	m	struct:MMcallinfo
forward	maxmatdef.h	/^       forward,                \/\/ compute forward matches$/;"	m	struct:Matchprocessinfo
fourcolumn	maxmatdef.h	/^       fourcolumn,              \/\/ always use 4 column format$/;"	m	struct:MMcallinfo
fourcolumn	maxmatdef.h	/^       fourcolumn,             \/\/ is option \\texttt{-F} on?$/;"	m	struct:Matchprocessinfo
freemultiseq	multiseq.cpp	/^void freemultiseq(Multiseq *multiseq)$/;"	f
freespaceviaptr	space.cpp	/^void freespaceviaptr(char *file,Uint line,void *ptr)$/;"	f
freestree	construct.cpp	/^void freestree(Suffixtree *stree)$/;"	f
generalcounter	streetyp.h	/^  void *generalcounter;$/;"	m	struct:Suffixtree
getCounter	prefix.hpp	/^        const int getCounter() const$/;"	f	class:prefix
getEdgelength	distribute.cpp	/^Uint getEdgelength(Uchar *left,Uchar *right)$/;"	f
getMaxNodesNumber	streedbg.cpp	/^Uint getMaxNodesNumber(Suffixtree *stree)$/;"	f
getPrefix	prefix.hpp	/^        const string getPrefix() const$/;"	f	class:prefix
getbranchinfostree	access.cpp	/^void getbranchinfostree(Suffixtree *stree,Uint whichinfo,$/;"	f
geterror	seterror.cpp	/^Sint geterror(void)$/;"	f
getheadstringstree	access.cpp	/^void getheadstringstree(Suffixtree *stree,Stringtype *str)$/;"	f
getlargelinkconstruction	construct.cpp	/^static Uint getlargelinkconstruction(Suffixtree *stree)$/;"	f	file:
getlargelinkstree	access.cpp	/^Uint getlargelinkstree(\/*@unused@*\/ Suffixtree *stree,Bref btptr,Uint depth)$/;"	f
getleafinfostree	access.cpp	/^void getleafinfostree(Suffixtree *stree,Leafinfo *leafinfo,Lref lptr)$/;"	f
getmaxdesclen	procmaxmat.cpp	/^static Sint getmaxdesclen(Multiseq *multiseq)$/;"	f	file:
getmaxmatinput	maxmatinp.cpp	/^Sint getmaxmatinput (Multiseq *subjectmultiseq, bool matchnucleotidesonly, char *subjectfile)$/;"	f
getmaxtextlenstree	access.cpp	/^Uint getmaxtextlenstree(void)$/;"	f
getoptindent	procopt.cpp	/^static Uint getoptindent(int *excludetab,OptionDescription *opt,Uint numofopt)$/;"	f	file:
getrecordnum	multiseq.cpp	/^Sint getrecordnum(Uint *recordseps,Uint numofrecords,Uint totalwidth,$/;"	f
getseqnum	multiseq.cpp	/^Sint getseqnum(Multiseq *multiseq,Uint position)$/;"	f
getspacepeak	space.cpp	/^Uint getspacepeak(void)$/;"	f
headend	streetyp.h	/^         *headend,            \/\/ of the head location \\((\\overline{u},v)\\). $/;"	m	struct:Suffixtree
headnode	streetyp.h	/^       *headnode,             \/\/ left component of head location$/;"	m	struct:Suffixtree
headnodedepth	streetyp.h	/^       headnodedepth,         \/\/ the depth of the headnode$/;"	m	struct:Suffixtree
headposition	streetyp.h	/^  Uint depth, headposition;$/;"	m	struct:Pathinfo
headposition	streetyp.h	/^  Uint headposition,        \/\/ the head position of the branching node$/;"	m	struct:Branchinfo
headstart	streetyp.h	/^  Uchar *headstart,          \/\/ these references represent the right component$/;"	m	struct:Suffixtree
inheritfrompath	findmaxmat.cpp	/^static void inheritfrompath(ArrayPathinfo *matchpath,Location *maxloc,Nodeinfo *stacktop,Bref nodeptr,Uint accessindex,Uint inheritdepth)$/;"	f	file:
initSuffixtree	construct.cpp	/^static void initSuffixtree(Suffixtree *stree,Uchar *text,Uint textlen)$/;"	f	file:
initmultiseq	multiseq.cpp	/^void initmultiseq(Multiseq *multiseq)$/;"	f
initoptions	procopt.cpp	/^void initoptions(OptionDescription *options,Uint numofoptions)$/;"	f
insertbranchnode	construct.cpp	/^static void insertbranchnode(Suffixtree *stree)$/;"	f	file:
insertinleaflist	dfs.cpp	/^static Sint insertinleaflist(Uint leafindex,\/*@unused@*\/ Bref lcpnode,$/;"	f	file:
insertleaf	construct.cpp	/^static void insertleaf(Suffixtree *stree)$/;"	f	file:
insertleafcalls	streetyp.h	/^  Uint insertleafcalls,$/;"	m	struct:Suffixtree
insertnode	streetyp.h	/^       insertnode,            \/\/ the node the split edge leads to $/;"	m	struct:Suffixtree
insertprev	streetyp.h	/^       insertprev,            \/\/ the edge preceeding the split edge$/;"	m	struct:Suffixtree
int2ref	access.cpp	/^static void int2ref(Suffixtree *stree,Reference *ref,Uint i)$/;"	f	file:
isalreadyset	optdesc.h	/^  bool isalreadyset,         \/\/ has the option already been set?$/;"	m	struct:OptionDescription
largelinklinkwork	streetyp.h	/^       largelinklinkwork,$/;"	m	struct:Suffixtree
largelinks	streetyp.h	/^       largelinks,$/;"	m	struct:Suffixtree
largelinkwork	streetyp.h	/^       largelinkwork,$/;"	m	struct:Suffixtree
largenode	streetyp.h	/^       largenode,             \/\/ number of large nodes$/;"	m	struct:Suffixtree
lastcharindex	streetyp.h	/^  Sint lastcharindex;$/;"	m	struct:Suffixtree
lcp	scanpref.cpp	/^static Uint lcp(Uchar *start1,Uchar *end1,Uchar *start2,Uchar *end2)$/;"	f	file:
leafcounts	streetyp.h	/^       *leafcounts;           \/\/ holds counts of the number of leafs in subtree$/;"	m	struct:Suffixtree
leaftab	streetyp.h	/^       *leaftab,              \/\/ stores the brother-references of the leafs$/;"	m	struct:Suffixtree
length	types.h	/^      Uint start, length;$/;"	m	struct:ListType
lineallocated	space.cpp	/^  Uint lineallocated;  \/\/ the linenumber where the$/;"	m	struct:Blockdescription	file:
linemapped	mapfile.cpp	/^static Uint linemapped[MAXMAPPEDFILES] = {0};       $/;"	v	file:
linklocstree	linkloc.cpp	/^void linklocstree(Suffixtree *stree,Location *outloc,Location *inloc)$/;"	f
linkrootchildren	construct.cpp	/^static void linkrootchildren(Suffixtree *stree)$/;"	f	file:
loc2stringstree	streedbg.cpp	/^static void loc2stringstree(Suffixtree *stree,Stringtype *s,Location *loc)$/;"	f	file:
locstring	streetyp.h	/^  Stringtype locstring; \/\/ string represented by location$/;"	m	struct:Location
main	toci.cpp	/^int main(int argc, char *argv[])$/;"	f
makedepthtabstree	depthtab.cpp	/^void makedepthtabstree(ArrayUint *depthtab,Suffixtree *stree)$/;"	f
makeleaflist	dfs.cpp	/^Sint makeleaflist(Suffixtree *stree,ArrayUint *leaflist,Reference *start)$/;"	f
makeleastlengthtext	maxmatopt.cpp	/^static void makeleastlengthtext(char *spacefortext)$/;"	f	file:
mappedbytes	mapfile.cpp	/^            mappedbytes[MAXMAPPEDFILES] = {0};  \/\/ size of the memory map$/;"	v	file:
markpos	multidef.h	/^  ArrayPosition markpos;$/;"	m	struct:Multiseq
matchnucleotidesonly	maxmatdef.h	/^       matchnucleotidesonly,    \/\/ match ONLY acgt's$/;"	m	struct:MMcallinfo
matchpath	findmaxmat.cpp	/^  ArrayPathinfo matchpath;        \/\/ path of br. nodes from ploc to maxloc$/;"	m	struct:Maxmatchinfo	file:
maxbranchdepth	streetyp.h	/^       maxbranchdepth,        \/\/ maximal depth of branching node$/;"	m	struct:Suffixtree
maxdesclength	maxmatdef.h	/^       maxdesclength,          \/\/ maximum length of a description$/;"	m	struct:Matchprocessinfo
maxerrormsg	seterror.cpp	/^Sint maxerrormsg(void)$/;"	f
maxlength	multidef.h	/^       maxlength;        \/\/ maximal number of chars of description to be shown$/;"	m	struct:Showdescinfo
maxloc	findmaxmat.cpp	/^  Location maxloc;                \/\/ location of \\texttt{pmax}$/;"	m	struct:Maxmatchinfo	file:
maxset	streetyp.h	/^       *maxset;$/;"	m	struct:Suffixtree
memoryptr	mapfile.cpp	/^static void *memoryptr[MAXMAPPEDFILES] = {NULL};$/;"	v	file:
messagespace	seterror.cpp	/^char *messagespace(void)$/;"	f
minmatchlength	findmaxmat.cpp	/^       minmatchlength,            \/\/ min length of a match to be reported$/;"	m	struct:Maxmatchinfo	file:
minmatchlength	maxmatdef.h	/^  Uint minmatchlength,          \/\/ minimal length of a match to be reported$/;"	m	struct:MMcallinfo
minmatchlength	maxmatdef.h	/^  Uint minmatchlength,         \/\/ minimum length of a match$/;"	m	struct:Matchprocessinfo
mmaddspace	mapfile.cpp	/^static void mmaddspace(Uint space)$/;"	f	file:
mmcheckspaceleak	mapfile.cpp	/^void mmcheckspaceleak(void)$/;"	f
mmgetspacepeak	mapfile.cpp	/^Uint mmgetspacepeak(void)$/;"	f
mmsubtractspace	mapfile.cpp	/^static void mmsubtractspace(Uint space)$/;"	f	file:
mmwrapspace	mapfile.cpp	/^Sint mmwrapspace(void)$/;"	f
mumcandtab	maxmatdef.h	/^  ArrayMUMcandidate mumcandtab;\/\/ a table containing MUM-candidates$/;"	m	struct:Matchprocessinfo
mumlength	mumcand.h	/^  Uint mumlength,    \/\/ length of the mum$/;"	m	struct:MUMcandidate
mumuniqueinquery	cleanMUMcand.cpp	/^Sint mumuniqueinquery(void *processinfo,$/;"	f
nextfreeStrings	arraydef.h	/^  Uint stringbufferlength, nextfreeStrings, allocatedStrings;$/;"	m	struct:ArrayStrings
nextfreeblock	space.cpp	/^            nextfreeblock = 0,  \/\/ index of next free block$/;"	v	file:
nextfreebranch	streetyp.h	/^       *nextfreebranch,       \/\/ reference to next free base addr. in branchtab$/;"	m	struct:Suffixtree
nextfreebranchnum	streetyp.h	/^       nextfreebranchnum,     \/\/ the number of the next free branch node$/;"	m	struct:Suffixtree
nextfreeleafnum	streetyp.h	/^  Uint nextfreeleafnum,       \/\/ the number of the next leaf$/;"	m	struct:Suffixtree
nextfreeleafptr	streetyp.h	/^       *nextfreeleafptr,      \/\/ points to next free entry in leaftab$/;"	m	struct:Suffixtree
nextnode	streetyp.h	/^  Reference nextnode;   \/\/ reference to node the edge points to$/;"	m	struct:Location
nextnode	streetyp.h	/^  Reference nextnode;$/;"	m	struct:Simpleloc
nodecount	streetyp.h	/^       nodecount,$/;"	m	struct:Suffixtree
nonmaximal	streetyp.h	/^       *nonmaximal,           \/\/ bit table: if node with headposition \\(i\\) is $/;"	m	struct:Suffixtree
numberofblocks	space.cpp	/^static Uint numberofblocks = 0, \/\/ numberofblocks$/;"	v	file:
numberofcells	space.cpp	/^       numberofcells;  \/\/ number of cells in the block$/;"	m	struct:Blockdescription	file:
numofqueryfiles	maxmatdef.h	/^       numofqueryfiles;         \/\/ number of query files$/;"	m	struct:MMcallinfo
numofsequences	multidef.h	/^       numofsequences,                 \/\/ the number of sequences$/;"	m	struct:Multiseq
occursinlist	procopt.cpp	/^static bool occursinlist(Uint i,int *list)$/;"	f	file:
onmaxpath	findmaxmat.cpp	/^  bool onmaxpath;$/;"	m	struct:Nodeinfo	file:
onsuccpath	streetyp.h	/^       onsuccpath,            \/\/ refers to node on success path of headnode$/;"	m	struct:Suffixtree
optname	optdesc.h	/^  char *optname,             \/\/ the option string, begins with -$/;"	m	struct:OptionDescription
optval	optdesc.h	/^  Uint optval;               \/\/ the unique number of an option$/;"	m	struct:OptionDescription
originalsequence	multidef.h	/^        *originalsequence;             \/\/ NULL or points to orig. sequence$/;"	m	struct:Multiseq
overallsequences	multiseq.cpp	/^Sint overallsequences(bool rcmode,Multiseq *multiseq,void *applyinfo,$/;"	f
parsemaxmatoptions	maxmatopt.cpp	/^Sint parsemaxmatoptions(MMcallinfo *mmcallinfo,int argc, char *argv[])$/;"	f
pos2pospair	multiseq.cpp	/^Sint pos2pospair(Multiseq *multiseq,PairUint *pos,Uint position)$/;"	f
prefix	prefix.hpp	/^        string prefix;$/;"	m	class:prefix
prefix	prefix.hpp	/^class prefix$/;"	c
previousnode	streetyp.h	/^  Bref previousnode;    \/\/ reference to previous node (which is branching)$/;"	m	struct:Location
processbranch1	findmaxmat.cpp	/^static bool processbranch1(Bref nodeptr,void *info)$/;"	f	file:
processbranch2	findmaxmat.cpp	/^static Sint processbranch2(\/*@unused@*\/ Bref nodeptr,void *info)$/;"	f	file:
processinfo	findmaxmat.cpp	/^  void *processinfo;            \/\/ first arg. when calling previous function$/;"	m	struct:Maxmatchinfo	file:
processleaf	findmaxmat.cpp	/^static Sint processleaf(Uint leafindex,\/*@unused@*\/ Bref lcpnode,void *info)$/;"	f	file:
processmatch	findmaxmat.cpp	/^  Processmatchfunction processmatch; \/\/ this function processes found match$/;"	m	struct:Maxmatchinfo	file:
procmaxmatches	procmaxmat.cpp	/^Sint procmaxmatches(MMcallinfo *mmcallinfo,Multiseq *subjectmultiseq)$/;"	f
procoption	procopt.cpp	/^Sint procoption(OptionDescription *opt,Uint numofopt,char *optstring)$/;"	f
program	maxmatdef.h	/^  char program[PATH_MAX+1],     \/\/ the path of the program$/;"	m	struct:MMcallinfo
query	findmaxmat.cpp	/^  Uchar *query,                   \/\/ the query string$/;"	m	struct:Maxmatchinfo	file:
querycommondepth	findmaxmat.cpp	/^  Uint querycommondepth;$/;"	m	struct:Nodeinfo	file:
queryfilelist	maxmatdef.h	/^       queryfilelist[MAXNUMOFQUERYFILES][PATH_MAX+1]; $/;"	m	struct:MMcallinfo
querylen	findmaxmat.cpp	/^  Uint querylen,                  \/\/ length of the current query$/;"	m	struct:Maxmatchinfo	file:
querymultiseq	maxmatdef.h	/^           querymultiseq;      \/\/ the Multiseq record of the queries$/;"	m	struct:Matchprocessinfo
queryseq	mumcand.h	/^       queryseq,     \/\/ number of the query sequence$/;"	m	struct:MUMcandidate
queryseqnum	findmaxmat.cpp	/^       queryseqnum,               \/\/ number of query sequence$/;"	m	struct:Maxmatchinfo	file:
querystart	mumcand.h	/^       querystart;   \/\/ start position in the query sequence      $/;"	m	struct:MUMcandidate
querysuffix	findmaxmat.cpp	/^        *querysuffix;             \/\/ current suffix of query$/;"	m	struct:Maxmatchinfo	file:
rcsequence	multidef.h	/^        *rcsequence,                   \/\/ NULL or points to $/;"	m	struct:Multiseq
ref	streetyp.h	/^  Bref ref;$/;"	m	struct:Pathinfo
relposition	multidef.h	/^       relposition;  \/\/ the relative position of the sequence$/;"	m	struct:Seqinfo
remain	streetyp.h	/^       remain;          \/\/ number of remaining characters on edge$/;"	m	struct:Location
remain	streetyp.h	/^  Uint remain,$/;"	m	struct:Simpleloc
replaceblanks	multidef.h	/^       replaceblanks,    \/\/ replaceblanks by underscore$/;"	m	struct:Showdescinfo
rescan	construct.cpp	/^static void rescan (Suffixtree *stree)$/;"	f	file:
rescanstree	linkloc.cpp	/^void rescanstree(Suffixtree *stree,Location *loc,$/;"	f
reseterror	seterror.cpp	/^void reseterror(void)$/;"	f
reversecomplement	maxmatdef.h	/^       reversecomplement,       \/\/ compute matches on reverse strand$/;"	m	struct:MMcallinfo
reversecomplement	maxmatdef.h	/^       reversecomplement,      \/\/ compute reverse complement matches$/;"	m	struct:Matchprocessinfo
rootchildren	streetyp.h	/^       *rootchildren;         \/\/ references to successors of root$/;"	m	struct:Suffixtree
rootsucclocationsstree	access.cpp	/^void rootsucclocationsstree(Suffixtree *stree,ArraySimpleloc *ll)$/;"	f
safestringcopy	safescpy.cpp	/^Sint safestringcopy(char *dest,char *source,Sint maxlen)$/;"	f
scanmultiplefastafile	maxmatinp.cpp	/^Sint scanmultiplefastafile (Multiseq *multiseq,$/;"	f
scanprefix	construct.cpp	/^static void scanprefix(Suffixtree *stree)$/;"	f	file:
scanprefixfromnodestree	scanpref.cpp	/^Uchar *scanprefixfromnodestree(Suffixtree *stree,Location *loc,Bref btptr,Uchar *left,Uchar *right,Uint rescanlength)$/;"	f
scanprefixstree	scanpref.cpp	/^Uchar *scanprefixstree(Suffixtree *stree,Location *outloc,$/;"	f
secondtime	streetyp.h	/^  bool secondtime;$/;"	m	struct:DFSstate
sentinel	streetyp.h	/^         *sentinel;           \/\/ points to the position of the \\(\\$\\)-symbol$/;"	m	struct:Suffixtree
seqlength	multidef.h	/^       seqlength,    \/\/ the length of the sequence$/;"	m	struct:Seqinfo
seqnum	multidef.h	/^  Uint seqnum,       \/\/ the sequence number in multiseq$/;"	m	struct:Seqinfo
seqstartpos	multidef.h	/^       seqstartpos,  \/\/ the position of the first character in multiseq.sequence$/;"	m	struct:Seqinfo
sequence	multidef.h	/^  Uchar *sequence,                     \/\/ the concatenated sequences$/;"	m	struct:Multiseq
set	prefix.hpp	/^        void set (int counter)$/;"	f	class:prefix
set	prefix.hpp	/^        void set (string prefix) $/;"	f	class:prefix
set	prefix.hpp	/^        void set (string prefix, int counter)$/;"	f	class:prefix
setatnewleaf	streetyp.h	/^  bool setatnewleaf;          \/\/ nil-reference is stored in new leaf$/;"	m	struct:Suffixtree
setdepthtab	depthtab.cpp	/^static void setdepthtab(ArrayUint *depthtab,Uint depth)$/;"	f	file:
seterror	seterror.cpp	/^void seterror(Sint code)$/;"	f
setlink	streetyp.h	/^       *setlink,              \/\/ address of a nil-reference$/;"	m	struct:Suffixtree
setmaxspace	space.cpp	/^static void setmaxspace(void)$/;"	f	file:
showdepthtab	depthtab.cpp	/^void showdepthtab(ArrayUint *dt)$/;"	f
showexclude	procopt.cpp	/^void showexclude(OptionDescription *opt,Sint *excludetab,Uint len)$/;"	f
showlocation	streedbg.cpp	/^void showlocation(FILE *fp,Suffixtree *stree,Location *loc)$/;"	f
showmaximalmatch	procmaxmat.cpp	/^static Sint showmaximalmatch (void *info,$/;"	f	file:
showoptdesc	procopt.cpp	/^static void showoptdesc(FILE *fp,Uint indentlevel,char *desc)$/;"	f	file:
showoptions	procopt.cpp	/^void showoptions(FILE *outfp,char *program,OptionDescription *opt,$/;"	f
showoptionswithoutexclude	procopt.cpp	/^void showoptionswithoutexclude(FILE *outfp,char *program,$/;"	f
showpathstree	access.cpp	/^void showpathstree(Suffixtree *stree,Bref bnode,$/;"	f
showreversepositions	maxmatdef.h	/^       showreversepositions,    \/\/ give reverse pos. rel. to orig. string$/;"	m	struct:MMcallinfo
showreversepositions	maxmatdef.h	/^       showreversepositions,   \/\/ is option \\texttt{-c} on?$/;"	m	struct:Matchprocessinfo
showseqandmaximalmatch	procmaxmat.cpp	/^static Sint showseqandmaximalmatch (void *info,$/;"	f	file:
showsequencedescription	procmaxmat.cpp	/^static void showsequencedescription(Multiseq *multiseq, Uint maxdesclength,$/;"	f	file:
showsequenceheader	procmaxmat.cpp	/^static void showsequenceheader(Multiseq *multiseq,$/;"	f	file:
showsequencelengths	maxmatdef.h	/^       showsequencelengths,     \/\/ show length of sequences on header line$/;"	m	struct:MMcallinfo
showsequencelengths	maxmatdef.h	/^       showsequencelengths,    \/\/ is option \\texttt{-L} on?$/;"	m	struct:Matchprocessinfo
showstate	streedbg.cpp	/^void showstate(Suffixtree *stree)$/;"	f
showstree	streedbg.cpp	/^void showstree(Suffixtree *stree)$/;"	f
showstring	maxmatdef.h	/^  bool showstring,              \/\/ show the matching string$/;"	m	struct:MMcallinfo
showstring	maxmatdef.h	/^  bool showstring,             \/\/ is option \\texttt{-s} on?$/;"	m	struct:Matchprocessinfo
showsubtree	streedbg.cpp	/^static void showsubtree(Suffixtree *stree,Uint indent,Uint *btptr)$/;"	f	file:
showsymbol	streedbg.cpp	/^char *showsymbol(Uchar c)$/;"	f
showsymbolstree	streetyp.h	/^  char * (*showsymbolstree)(Uchar,Uchar *);$/;"	m	struct:Suffixtree
showtable	streedbg.cpp	/^void showtable(Suffixtree *stree,bool final)$/;"	f
showthesymbolstring	streedbg.cpp	/^void showthesymbolstring(FILE *fp,Uchar *tlast,Uchar *left,$/;"	f
showusage	maxmatopt.cpp	/^static void showusage(char *program,OptionDescription *options,$/;"	f	file:
simplefileOpen	mapfile.cpp	/^Sint simplefileOpen(char *filename,Uint *numofbytes)$/;"	f
sizeofcells	space.cpp	/^  Uint sizeofcells,    \/\/ size of cells of the block$/;"	m	struct:Blockdescription	file:
skipprefix	multidef.h	/^  Uint skipprefix,       \/\/ always skip this number of prefixes$/;"	m	struct:Showdescinfo
smallnode	streetyp.h	/^       smallnode,             \/\/ number of small nodes$/;"	m	struct:Suffixtree
smallnotcompleted	streetyp.h	/^       smallnotcompleted,     \/\/ the number of small nodes in the current chain$/;"	m	struct:Suffixtree
sortMUMcandidates	cleanMUMcand.cpp	/^static void sortMUMcandidates(ArrayMUMcandidate *mumcand)$/;"	f	file:
spaceStrings	arraydef.h	/^  Stringtype *spaceStrings;$/;"	m	struct:ArrayStrings
spaceforbranchtab	construct.cpp	/^static void spaceforbranchtab(Suffixtree *stree)$/;"	f	file:
spacepeak	mapfile.cpp	/^            spacepeak = 0,                 \/\/ maximally mapped num of bytes$/;"	v	file:
spacepeak	space.cpp	/^            spacepeak = 0;      \/\/ maximally allocated num of bytes$/;"	v	file:
spaceptr	space.cpp	/^  void *spaceptr;      \/\/ ptr to the spaceblock$/;"	m	struct:Blockdescription	file:
splitstreeH	distribute.cpp	/^void splitstreeH(Suffixtree *stree, Uint *consumption, Uint size)$/;"	f
splitsubstreeH	distribute.cpp	/^void splitsubstreeH(Suffixtree *stree, sparsetable<Uint*> &table, Uchar *buffer,Uint *btptr, Uint wordsize)$/;"	f
stack	streetyp.h	/^  ArrayBref stack;$/;"	m	struct:DFSstate
start	types.h	/^      Uint start, length;$/;"	m	struct:ListType
startdesc	multidef.h	/^  Uint *startdesc,                     \/\/ of length numofsequences + 1$/;"	m	struct:Multiseq
storeMUMcandidate	procmaxmat.cpp	/^static Sint storeMUMcandidate (void *info,$/;"	f	file:
stree	findmaxmat.cpp	/^  Suffixtree *stree;              \/\/ reference to suffix tree of subject-seq$/;"	m	struct:Maxmatchinfo	file:
stree	maxmatdef.h	/^  Suffixtree stree;            \/\/ the suffix tree of the subject-sequence$/;"	m	struct:Matchprocessinfo
stringbuffer	arraydef.h	/^  Uchar *stringbuffer;$/;"	m	struct:ArrayStrings
stringbufferlength	arraydef.h	/^  Uint stringbufferlength, nextfreeStrings, allocatedStrings;$/;"	m	struct:ArrayStrings
subjectfile	maxmatdef.h	/^       subjectfile[PATH_MAX+1], \/\/ filename of the subject-sequence$/;"	m	struct:MMcallinfo
subjectmultiseq	maxmatdef.h	/^  Multiseq *subjectmultiseq,   \/\/ reference to multiseq of subject$/;"	m	struct:Matchprocessinfo
subtractspace	space.cpp	/^static void subtractspace(Uint space)$/;"	f	file:
succlocationsstree	access.cpp	/^void succlocationsstree(Suffixtree *stree,bool nosentinel,Simpleloc *loc,$/;"	f
suffixlink	streetyp.h	/^  Bref suffixlink;          \/\/ the suffix link is always to a branching node$/;"	m	struct:Branchinfo
taillcp	construct.cpp	/^static Uint taillcp(Suffixtree *stree,Uchar *start1, Uchar *end1)$/;"	f	file:
tailptr	streetyp.h	/^         *tailptr;            \/\/ points to the tail$/;"	m	struct:Suffixtree
text	streetyp.h	/^  Uchar *text,               \/\/ points to the input string$/;"	m	struct:Suffixtree
textlen	streetyp.h	/^  Uint textlen,               \/\/ the length of the input string$/;"	m	struct:Suffixtree
textpos	streetyp.h	/^       textpos;  \/\/ these last two items are redundant and can be computed$/;"	m	struct:Simpleloc
toleaf	streetyp.h	/^  bool toleaf;$/;"	m	struct:Reference
totallength	multidef.h	/^       totallength;                    \/\/ the total length of all sequences$/;"	m	struct:Multiseq
uint0	types.h	/^      Uint uint0, uint1, uint2;$/;"	m	struct:ThreeUint
uint0	types.h	/^    Uint uint0, uint1;$/;"	m	struct:PairUint
uint1	types.h	/^      Uint uint0, uint1, uint2;$/;"	m	struct:ThreeUint
uint1	types.h	/^    Uint uint0, uint1;$/;"	m	struct:PairUint
uint2	types.h	/^      Uint uint0, uint1, uint2;$/;"	m	struct:ThreeUint
untilfirstblank	multidef.h	/^       untilfirstblank;  \/\/ only show sequence until first blank$/;"	m	struct:Showdescinfo
wccSequence	procmaxmat.cpp	/^static void wccSequence (Uchar *seq,$/;"	f	file:
wordsize	maxmatdef.h	/^       wordsize,                \/\/ length of word to store in Direct Access Table$/;"	m	struct:MMcallinfo
wordsize	maxmatdef.h	/^       wordsize,               \/\/ wordsize for Direct access table$/;"	m	struct:Matchprocessinfo
wrapspace	space.cpp	/^void wrapspace(void)$/;"	f
