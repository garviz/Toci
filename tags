!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
CC	Makefile	/^CC = g++$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -pg -m64 -fopenmp -D_GLIBCXX_PARALLEL -msse4.2$/;"	m
CHILD	sparseSA.hpp	/^  vector<long long> CHILD; \/\/child table$/;"	m	struct:sparseSA
CXXFLAGS	Makefile	/^CXXFLAGS = -g -pg -m64 -fopenmp -D_GLIBCXX_PARALLEL -msse4.2 -std=c++11 -std=gnu++11$/;"	m
DISTRIBUTE_H	distribute.h	19;"	d
I	qsufsort.c	/^static int *I,                  \/* group array, ultimately suffix array.*\/$/;"	v	file:
ISA	sparseSA.hpp	/^  vector<long long> ISA;  \/\/ Inverse suffix array.$/;"	m	struct:sparseSA
K	mummer.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
K	sparseSA.hpp	/^  long long K; \/\/ suffix sampling, K = 1 every suffix, K = 2 every other suffix, K = 3, every 3rd sffix$/;"	m	struct:sparseSA
KEY	qsufsort.c	21;"	d	file:
Kvalues	sparseSA.cpp	/^  vector<long> Kvalues; \/\/ Values of K this thread should process.$/;"	m	struct:thread_data	file:
LCP	sparseSA.hpp	/^  vec_uchar LCP; \/\/ Simulates a vector<int> LCP.$/;"	m	struct:sparseSA
LCPCHILD	sparseSA.cpp	20;"	d	file:
LIBS	Makefile	/^LIBS = -lstdc++ -lpthread$/;"	m
M	ex.cpp	/^  vector<item_t> M;$/;"	m	struct:vec_uchar	file:
M	sparseSA.hpp	/^  vector<item_t> M;$/;"	m	struct:vec_uchar
MAM	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MAM	sparseSA.hpp	/^  void MAM(string &P, int chunk, int chunks, vector<match_t> &matches, long long min_len, long long& memCount, bool print) { $/;"	f	struct:sparseSA
MED3	qsufsort.c	23;"	d	file:
MEM	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MEM	sparseSA.cpp	/^void sparseSA::MEM(string &P, vector<match_t> &matches, long long min_len, bool print, long long& currentCount, int num_threads) {$/;"	f	class:sparseSA
MEMthread	sparseSA.cpp	/^void *MEMthread(void *arg) {$/;"	f
MUM	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MUM	sparseSA.cpp	/^void sparseSA::MUM(string &P, vector<match_t> &unique, long long min_len, long long& currentCount, bool print) {$/;"	f	class:sparseSA
MUMParallel	sparseSA.cpp	/^void sparseSA::MUMParallel(string &P, int chunks, vector<match_t> &unique, long long min_len, long long& currentCount, bool print) {$/;"	f	class:sparseSA
N	sparseSA.hpp	/^  long long N; \/\/!< Length of the sequence.$/;"	m	struct:sparseSA
NKm1	sparseSA.hpp	/^  long long NKm1; \/\/ N\/K - 1$/;"	m	struct:sparseSA
P	sparseSA.cpp	/^  string *P; \/\/ Query string.$/;"	m	struct:thread_data	file:
PRINT	sparseSA.cpp	27;"	d	file:
Reference	sparseSA.hpp	/^  string Reference; \/\/!< Reference to sequence data.$/;"	m	struct:sparseSA
SA	sparseSA.hpp	/^  vector<long long> SA;  \/\/ Suffix array.$/;"	m	struct:sparseSA
SIZE	ex.cpp	35;"	d	file:
SRC	Makefile	/^SRC = mummer.cpp qsufsort.c sparseSA.cpp fasta.cpp$/;"	m
SWAP	qsufsort.c	22;"	d	file:
Safe_malloc	distribute.cpp	/^void *  Safe_malloc  (size_t Len)$/;"	f
Safe_realloc	distribute.cpp	/^void *  Safe_realloc  (void * Q, size_t Len)$/;"	f
V	qsufsort.c	/^   *V,                          \/* inverse array, ultimately inverse of I.*\/$/;"	v	file:
_4column	mummer.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
_4column	sparseSA.hpp	/^  bool _4column; \/\/ Use 4 column output format.$/;"	m	struct:sparseSA
__FASTA_HPP__	fasta.hpp	2;"	d
__sparseSA_hpp__	sparseSA.hpp	2;"	d
automatic	mummer.cpp	/^bool automatic = true;$/;"	v
automaticSkip	mummer.cpp	/^bool automaticSkip = true;$/;"	v
base	genDNA.py	/^    base = randint(1,4)$/;"	v
bsearch_left	sparseSA.cpp	/^long sparseSA::bsearch_left(char c, long long i, long long s, long long e) {$/;"	f	class:sparseSA
bsearch_right	sparseSA.cpp	/^long sparseSA::bsearch_right(char c, long long i, long long s, long long e) {$/;"	f	class:sparseSA
bucketsort	qsufsort.c	/^static void bucketsort(int *x, int *p, int n, int k)$/;"	f	file:
by_ref	sparseSA.cpp	/^struct by_ref { bool operator() (const match_t &a, const match_t &b) const { if(a.ref == b.ref) return a.len > b.len; else return a.ref < b.ref; }  };$/;"	s	file:
child	mummer.cpp	/^bool child = true;$/;"	v
choose_pivot	qsufsort.c	/^static int choose_pivot(int *p, int n) {$/;"	f	file:
chunks	mummer.cpp	/^int chunks = 1;$/;"	v
collectMEMs	sparseSA.cpp	/^void sparseSA::collectMEMs(string &P, long long prefix, interval_t mli, interval_t xmi, vector<match_t> &matches, long long min_len, bool print) {$/;"	f	class:sparseSA
cout_mutex	sparseSA.cpp	/^pthread_mutex_t cout_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
createTable	distribute.cpp	/^void createTable(Matchprocessinfo *matchprocessinfo) $/;"	f
depth	sparseSA.hpp	/^  long long depth, start, end;$/;"	m	struct:interval_t
descr	sparseSA.hpp	/^  vector<string> &descr; \/\/ Descriptions of concatenated sequences.$/;"	m	struct:sparseSA
dna	genDNA.py	/^dna = {1 : "a", 2 : "c", 3 : "g", 4 : "t"}$/;"	v
encoding	distribute.cpp	/^Uint encoding(Uchar *example, int wordsize) $/;"	f
end	sparseSA.hpp	/^  long long depth, start, end;$/;"	m	struct:interval_t
expand_link	sparseSA.hpp	/^  inline bool expand_link(interval_t &link) {$/;"	f	struct:sparseSA
fillTable	distribute.cpp	/^void fillTable(Suffixtree *stree, Table& table, Uchar *buffer,Uint *btptr, short int wordsize)$/;"	f
findMAM	sparseSA.cpp	/^void sparseSA::findMAM(string &P, int chunk, int chunks, vector<match_t> &matches, long long min_len, long long& currentCount, bool print) {$/;"	f	class:sparseSA
findMEM	sparseSA.cpp	/^void sparseSA::findMEM(long long k, string &P, vector<match_t> &matches, long long min_len, bool print) {$/;"	f	class:sparseSA
find_Lmaximal	sparseSA.cpp	/^void sparseSA::find_Lmaximal(string &P, long long prefix, long long i, long long len, vector<match_t> &matches, long long min_len, bool print) {$/;"	f	class:sparseSA
forwards	mummer.cpp	/^bool forwards = true;$/;"	v
from_set	sparseSA.hpp	/^  void from_set(long hit, long &seq, long &seqpos) {$/;"	f	struct:sparseSA
h	qsufsort.c	/^   h;                           \/* length of already-sorted prefixes.*\/$/;"	v	file:
hasChild	sparseSA.hpp	/^  bool hasChild;$/;"	m	struct:sparseSA
hasSufLink	sparseSA.hpp	/^  bool hasSufLink;$/;"	m	struct:sparseSA
hashMmH3	ex.cpp	/^struct hashMmH3 {$/;"	s	file:
idx	ex.cpp	/^    size_t idx; int val;$/;"	m	struct:vec_uchar::item_t	file:
idx	sparseSA.hpp	/^    size_t idx; long long val;$/;"	m	struct:vec_uchar::item_t
init	ex.cpp	/^  void init() {$/;"	f	struct:vec_uchar
init	sparseSA.hpp	/^  void init() {$/;"	f	struct:vec_uchar
inter	ex.cpp	/^    inter() : l(-1), r(-2) {}$/;"	f	struct:inter
inter	ex.cpp	/^    inter(long lv, long rv) : l(lv), r(rv) {}$/;"	f	struct:inter
inter	ex.cpp	/^struct inter {$/;"	s	file:
inter	sparseSA.hpp	/^    inter() : l(-1), r(-2) {}$/;"	f	struct:inter
inter	sparseSA.hpp	/^    inter(long long lv, long long rv) : l(lv), r(rv) {}$/;"	f	struct:inter
inter	sparseSA.hpp	/^struct inter {$/;"	s
interval_t	sparseSA.hpp	/^  interval_t() { start = 1; end = 0; depth = -1; }$/;"	f	struct:interval_t
interval_t	sparseSA.hpp	/^  interval_t(long long s, long long e, long long d) { start = s; end = e; depth = d; }$/;"	f	struct:interval_t
interval_t	sparseSA.hpp	/^struct interval_t {$/;"	s
is_leftmaximal	sparseSA.cpp	/^bool sparseSA::is_leftmaximal(string &P, long p1, long p2) {$/;"	f	class:sparseSA
item_t	ex.cpp	/^    item_t(size_t i, int v) { idx = i; val = v; }$/;"	f	struct:vec_uchar::item_t
item_t	ex.cpp	/^  struct item_t{$/;"	s	struct:vec_uchar	file:
item_t	sparseSA.hpp	/^    item_t(size_t i, long long v) { idx = i; val = v; }$/;"	f	struct:vec_uchar::item_t
item_t	sparseSA.hpp	/^  struct item_t{$/;"	s	struct:vec_uchar
l	ex.cpp	/^    long l = -1, r = -2;$/;"	m	struct:inter	file:
l	sparseSA.hpp	/^    long long l = -1, r = -2;$/;"	m	struct:inter
len	sparseSA.hpp	/^  long len; \/\/ length of match$/;"	m	struct:match_t
length	genDNA.py	/^length = sys.argv[1]$/;"	v
load_fasta	fasta.cpp	/^void load_fasta(string filename, string &S, vector<string> &descr, vector<long> &startpos) {$/;"	f
logN	sparseSA.hpp	/^  long long logN; \/\/ ceil(log(N)) $/;"	m	struct:sparseSA
main	ex.cpp	/^int main (int argc, char *argv[]) {$/;"	f
main	mummer.cpp	/^int main(int argc, char* argv[]) {$/;"	f
match_t	sparseSA.hpp	/^  match_t() { ref = 0; query = 0, len = 0; }$/;"	f	struct:match_t
match_t	sparseSA.hpp	/^  match_t(long r, long q, long l) { ref = r; query = q; len = l; }$/;"	f	struct:match_t
match_t	sparseSA.hpp	/^struct match_t {$/;"	s
maxdescrlen	sparseSA.hpp	/^  long maxdescrlen; \/\/ Maximum length of the sequence description, used for formatting.$/;"	m	struct:sparseSA
memCount	sparseSA.cpp	/^long memCount = 0;$/;"	v
min_len	mummer.cpp	/^int min_len = 20;$/;"	v
min_len	sparseSA.cpp	/^  int min_len; \/\/ Minimum length of match.$/;"	m	struct:thread_data	file:
mum_t	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	g	file:
nucleotides_only	mummer.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
num_threads	mummer.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
offset	sparseSA.hpp	/^  unordered_map<string,interval_t> offset;$/;"	m	struct:sparseSA
operator ()	ex.cpp	/^    size_t operator() (const char *preffix) const$/;"	f	struct:hashMmH3
operator ()	sparseSA.cpp	/^struct by_ref { bool operator() (const match_t &a, const match_t &b) const { if(a.ref == b.ref) return a.len > b.len; else return a.ref < b.ref; }  };$/;"	f	struct:by_ref
operator <	ex.cpp	/^    bool operator < (item_t t) const { return idx < t.idx;  }$/;"	f	struct:vec_uchar::item_t
operator <	sparseSA.hpp	/^    bool operator < (item_t t) const { return idx < t.idx;  }$/;"	f	struct:vec_uchar::item_t
operator []	ex.cpp	/^ int operator[] (size_t idx) {$/;"	f	struct:vec_uchar
operator []	sparseSA.hpp	/^ int operator[] (size_t idx) {$/;"	f	struct:vec_uchar
printESA	ex.cpp	/^void printESA(const fid_Suffixarray *esa, fid_Projectfile *project) {$/;"	f
printSubstring	mummer.cpp	/^bool printSubstring = false;$/;"	v
printSubstring	sparseSA.hpp	/^  bool printSubstring;$/;"	m	struct:sparseSA
print_length	mummer.cpp	/^bool print_length = false;$/;"	v
print_match	sparseSA.cpp	/^void sparseSA::print_match(match_t m) {$/;"	f	class:sparseSA
print_match	sparseSA.cpp	/^void sparseSA::print_match(match_t m_new, vector<match_t> &buf) {$/;"	f	class:sparseSA
print_match	sparseSA.cpp	/^void sparseSA::print_match(string meta, vector<match_t> &buf, bool rc) {$/;"	f	class:sparseSA
query	sparseSA.hpp	/^  long query; \/\/ position in query$/;"	m	struct:match_t
query_arg	mummer.cpp	/^struct query_arg {$/;"	s	file:
query_fasta	mummer.cpp	/^string query_fasta;$/;"	v
query_thread	mummer.cpp	/^void *query_thread(void *arg_) {$/;"	f
query_threads	mummer.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
r	ex.cpp	/^    long l = -1, r = -2;$/;"	m	struct:inter	file:
r	qsufsort.c	/^   r,                           \/* number of symbols aggregated by transform.*\/$/;"	v	file:
r	sparseSA.hpp	/^    long long l = -1, r = -2;$/;"	m	struct:inter
randint	genDNA.py	/^from random import randint$/;"	i
ref	sparseSA.hpp	/^  long ref; \/\/ position in reference sequence$/;"	m	struct:match_t
reset	sparseSA.hpp	/^  void reset(long e) { start = 0; end = e; depth = 0; }$/;"	f	struct:interval_t
resize	ex.cpp	/^  void resize(size_t N) { vec.resize(N); }$/;"	f	struct:vec_uchar
resize	sparseSA.hpp	/^  void resize(size_t N) { vec.resize(N); }$/;"	f	struct:vec_uchar
rev_comp	mummer.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
reverse_complement	fasta.cpp	/^void reverse_complement(string &seq_rc, bool nucleotides_only) {$/;"	f
sa	mummer.cpp	/^sparseSA *sa;$/;"	v
sa	sparseSA.cpp	/^  sparseSA *sa; \/\/ Suffix array + aux informaton$/;"	m	struct:thread_data	file:
search	sparseSA.cpp	/^bool sparseSA::search(string &P, long long &start, long long &end) {$/;"	f	class:sparseSA
select_sort_split	qsufsort.c	/^static void select_sort_split(int *p, int n) {$/;"	f	file:
seq	genDNA.py	/^seq = []$/;"	v
set	ex.cpp	/^  void set(size_t idx, int v) {$/;"	f	struct:vec_uchar
set	sparseSA.hpp	/^  void set(size_t idx, int v) {$/;"	f	struct:vec_uchar
setBoth	mummer.cpp	/^bool setBoth = false;$/;"	v
setRevComp	mummer.cpp	/^bool setRevComp = false;$/;"	v
size	ex.cpp	/^    long size() {return r-l+1;}$/;"	f	struct:inter
size	ex.cpp	/^  size_t size(void) {$/;"	f	struct:vec_uchar
size	sparseSA.hpp	/^    long size() {return r-l+1;}$/;"	f	struct:inter
size	sparseSA.hpp	/^  long size() { return end - start + 1; }$/;"	f	struct:interval_t
skip	mummer.cpp	/^  int skip;$/;"	m	struct:query_arg	file:
skip0	mummer.cpp	/^  int skip0;$/;"	m	struct:query_arg	file:
sort_split	qsufsort.c	/^static void sort_split(int *p, int n)$/;"	f	file:
sparseMult	mummer.cpp	/^int sparseMult=1;$/;"	v
sparseMult	sparseSA.hpp	/^  long long sparseMult;$/;"	m	struct:sparseSA
sparseSA	sparseSA.cpp	/^sparseSA::sparseSA(string &R_, vector<string> &descr_, vector<long long> &startpos_, bool __4column, long long K_, bool suflink_, bool child_, int sparseMult_, bool printSubstring_) : $/;"	f	class:sparseSA
sparseSA	sparseSA.hpp	/^struct sparseSA {$/;"	s
start	sparseSA.hpp	/^  long long depth, start, end;$/;"	m	struct:interval_t
startpos	sparseSA.hpp	/^  vector<long long> &startpos; \/\/ Lengths of concatenated sequences.$/;"	m	struct:sparseSA
suffixlink	sparseSA.cpp	/^bool sparseSA::suffixlink(interval_t &m) {$/;"	f	class:sparseSA
suffixsort	qsufsort.c	/^void suffixsort(int *x, int *p, int n, int k, int l)$/;"	f
suflink	mummer.cpp	/^bool suflink = true;$/;"	v
sys	genDNA.py	/^import sys$/;"	i
thread_data	sparseSA.cpp	/^struct thread_data {$/;"	s	file:
top_down	sparseSA.cpp	/^bool sparseSA::top_down(char c, long long i, long long &start, long long &end) {$/;"	f	class:sparseSA
top_down_child	sparseSA.cpp	/^bool sparseSA::top_down_child(char c, interval_t &cur){$/;"	f	class:sparseSA
top_down_faster	sparseSA.cpp	/^bool sparseSA::top_down_faster(char c, long long i, long long &start, long long &end) {$/;"	f	class:sparseSA
transform	qsufsort.c	/^static int transform(int *x, int *p, int n, int k, int l, int q)$/;"	f	file:
traverse	sparseSA.cpp	/^void sparseSA::traverse(string &P, long prefix, interval_t &cur, long long min_len) {$/;"	f	class:sparseSA
traverse_faster	sparseSA.cpp	/^void sparseSA::traverse_faster(const string &P,const long long prefix, interval_t &cur, long long min_len){$/;"	f	class:sparseSA
trim	fasta.cpp	/^void trim(string &line, long &start, long &end) {$/;"	f
type	mummer.cpp	/^mum_t type = MAM;$/;"	v
update	ex.cpp	/^    void update(long val) {$/;"	f	struct:inter
update	sparseSA.hpp	/^    void update(long long val) { $/;"	f	struct:inter
update_group	qsufsort.c	/^static void update_group(int *pl, int *pm)$/;"	f	file:
usage	mummer.cpp	/^void usage(string prog) {$/;"	f
val	ex.cpp	/^    size_t idx; int val;$/;"	m	struct:vec_uchar::item_t	file:
val	sparseSA.hpp	/^    size_t idx; long long val;$/;"	m	struct:vec_uchar::item_t
vec	ex.cpp	/^  vector<unsigned char> vec;  \/\/ LCP values from 0-65534$/;"	m	struct:vec_uchar	file:
vec	sparseSA.hpp	/^  vector<unsigned char> vec;  \/\/ LCP values from 0-65534$/;"	m	struct:vec_uchar
vec_uchar	ex.cpp	/^struct vec_uchar {$/;"	s	file:
vec_uchar	sparseSA.hpp	/^struct vec_uchar {$/;"	s
