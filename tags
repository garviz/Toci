!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Background	papers/APBC2012/wga_APBC2012.tex	/^        \\paragraph*{Background:} $/;"	P
Background	papers/APBC2012/wga_APBC2012.tex	/^\\section*{Background}$/;"	s
CHILD	sparseSA.hpp	/^  vector<int> CHILD; \/\/child table$/;"	m	struct:sparseSA
Conclusions	eval2012/evaluation2012.tex	/^\\section{Conclusions}$/;"	s
Conclusions	papers/APBC2012/wga_APBC2012.tex	/^        \\paragraph*{Conclusions:} $/;"	P
Conclusions	papers/APBC2012/wga_APBC2012.tex	/^\\section*{Conclusions}$/;"	s
Conclusions	presentations/LLEIDA/wga_hpc.tex	/^\\section{Conclusions}$/;"	s
Distributed and parallel search of maximal matches	eval2012/evaluation2012.tex	/^\\section{Distributed and parallel search of maximal matches}$/;"	s
Distributed suffix tree	eval2012/evaluation2012.tex	/^\\section{Distributed suffix tree}$/;"	s
Drawbacks	papers/APBC2012/wga_APBC2012.tex	/^\\subsection*{Drawbacks}$/;"	b
FLAGS	Makefile	/^FLAGS = -O3 -g -m64 -fopenmp$/;"	m
Finding MUMs in a suffix tree	papers/BBC2013/mum-multithread.tex	/^\\subsubsection{Finding MUMs in a suffix tree} $/;"	b
I	qsufsort.c	/^static int *I,                  \/* group array, ultimately suffix array.*\/$/;"	v	file:
ISA	sparseSA.hpp	/^  vector<int> ISA;  \/\/ Inverse suffix array.$/;"	m	struct:sparseSA
Introduction	papers/BBC2013/procs-sample.tex	/^\\section{Introduction}$/;"	s
K	mummer.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
K	sparseSA.hpp	/^  long K; \/\/ suffix sampling, K = 1 every suffix, K = 2 every other suffix, K = 3, every 3rd sffix$/;"	m	struct:sparseSA
KEY	qsufsort.c	21;"	d	file:
Kvalues	sparseSA.cpp	/^  vector<long> Kvalues; \/\/ Values of K this thread should process.$/;"	m	struct:thread_data	file:
LCP	sparseSA.hpp	/^  vec_uchar LCP; \/\/ Simulates a vector<int> LCP.$/;"	m	struct:sparseSA
M	sparseSA.hpp	/^  vector<item_t> M;$/;"	m	struct:vec_uchar
MAM	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MAM	sparseSA.hpp	/^  void MAM(string &P, int chunk, int chunks, vector<match_t> &matches, int min_len, long& memCount, bool print) { $/;"	f	struct:sparseSA
MED3	qsufsort.c	23;"	d	file:
MEM	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MEM	sparseSA.cpp	/^void sparseSA::MEM(string &P, vector<match_t> &matches, int min_len, bool print, long& currentCount, int num_threads) {$/;"	f	class:sparseSA
MEMthread	sparseSA.cpp	/^void *MEMthread(void *arg) {$/;"	f
MUM	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	e	enum:mum_t	file:
MUM	sparseSA.cpp	/^void sparseSA::MUM(string &P, vector<match_t> &unique, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
MUMParallel	sparseSA.cpp	/^void sparseSA::MUMParallel(string &P, int chunks, vector<match_t> &unique, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
MUMmer	papers/APBC2012/wga_APBC2012.tex	/^\\subsection{MUMmer}$/;"	b
Methods	papers/APBC2012/wga_APBC2012.tex	/^\\section*{Methods}$/;"	s
N	sparseSA.hpp	/^  long N; \/\/!< Length of the sequence.$/;"	m	struct:sparseSA
NKm1	sparseSA.hpp	/^  long NKm1; \/\/ N\/K - 1$/;"	m	struct:sparseSA
Objectives	eval2012/evaluation2012.tex	/^\\section{Objectives}$/;"	s
Objectives	presentations/LLEIDA/wga_hpc.tex	/^\\section{Objectives}$/;"	s
P	sparseSA.cpp	/^  string *P; \/\/ Query string.$/;"	m	struct:thread_data	file:
Parallel search of maximal unique matches	presentations/LLEIDA/wga_hpc.tex	/^\\section{Parallel search of maximal unique matches}$/;"	s
Parallelism technique	papers/JP2012/wga_parallelization.tex	/^\\section{Parallelism technique}$/;"	s
Problem definition	eval2012/evaluation2012.tex	/^\\section{Problem definition}$/;"	s
Problem definition	presentations/LLEIDA/wga_hpc.tex	/^\\section{Problem definition}$/;"	s
References	papers/BBC2013/procs-sample.tex	/^\\section*{References}$/;"	s
Results	papers/APBC2012/wga_APBC2012.tex	/^        \\paragraph*{Results:} We evaluate several genome sizes in order to test if our novel parallelization reduces the execution time and it produces the same set of matches than the serial execution. A data level parallelism is used in the reference and query genome.$/;"	P
Results and Discussion	papers/APBC2012/wga_APBC2012.tex	/^\\section*{Results and Discussion}$/;"	s
S	sparseSA.hpp	/^  string &S; \/\/!< Reference to sequence data.$/;"	m	struct:sparseSA
SA	sparseSA.hpp	/^  vector<unsigned int> SA;  \/\/ Suffix array.$/;"	m	struct:sparseSA
SRC	Makefile	/^SRC = mummer.cpp qsufsort.c sparseSA.cpp fasta.cpp$/;"	m
SWAP	qsufsort.c	22;"	d	file:
Structure	papers/BBC2013/procs-sample.tex	/^\\subsection{Structure}$/;"	b
Tables	papers/BBC2013/procs-sample.tex	/^\\subsection{Tables}$/;"	b
Test	presentations/LLEIDA/alg.tex	/^\\section{Test}$/;"	s
The MUM an heuristic approach	papers/BBC2013/mum-multithread.tex	/^\\subsection{The  MUM: an heuristic approach}$/;"	b
V	qsufsort.c	/^   *V,                          \/* inverse array, ultimately inverse of I.*\/$/;"	v	file:
_4column	mummer.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
_4column	sparseSA.hpp	/^  bool _4column; \/\/ Use 4 column output format.$/;"	m	struct:sparseSA
__FASTA_HPP__	fasta.hpp	2;"	d
__sparseSA_hpp__	sparseSA.hpp	2;"	d
automatic	mummer.cpp	/^bool automatic = true;$/;"	v
automaticSkip	mummer.cpp	/^bool automaticSkip = true;$/;"	v
base	genDNA.py	/^    base = randint(1,4)$/;"	v
bsearch_left	sparseSA.cpp	/^long sparseSA::bsearch_left(char c, long i, long s, long e) {$/;"	f	class:sparseSA
bsearch_right	sparseSA.cpp	/^long sparseSA::bsearch_right(char c, long i, long s, long e) {$/;"	f	class:sparseSA
bucketsort	qsufsort.c	/^static void bucketsort(int *x, int *p, int n, int k)$/;"	f	file:
by_ref	sparseSA.cpp	/^struct by_ref { bool operator() (const match_t &a, const match_t &b) const { if(a.ref == b.ref) return a.len > b.len; else return a.ref < b.ref; }  };$/;"	s	file:
child	mummer.cpp	/^bool child = true;$/;"	v
choose_pivot	qsufsort.c	/^static int choose_pivot(int *p, int n) {$/;"	f	file:
chunks	mummer.cpp	/^int chunks = 1;$/;"	v
collectMEMs	sparseSA.cpp	/^void sparseSA::collectMEMs(string &P, long prefix, interval_t mli, interval_t xmi, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
computeChild	sparseSA.cpp	/^void sparseSA::computeChild() {$/;"	f	class:sparseSA
computeLCP	sparseSA.cpp	/^void sparseSA::computeLCP() {$/;"	f	class:sparseSA
cout_mutex	sparseSA.cpp	/^pthread_mutex_t cout_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
depth	sparseSA.hpp	/^  long depth, start, end;$/;"	m	struct:interval_t
descr	sparseSA.hpp	/^  vector<string> &descr; \/\/ Descriptions of concatenated sequences.$/;"	m	struct:sparseSA
dna	genDNA.py	/^dna = {1 : "a", 2 : "c", 3 : "g", 4 : "t"}$/;"	v
end	sparseSA.hpp	/^  long depth, start, end;$/;"	m	struct:interval_t
expand_link	sparseSA.hpp	/^  inline bool expand_link(interval_t &link) {$/;"	f	struct:sparseSA
findMAM	sparseSA.cpp	/^void sparseSA::findMAM(string &P, int chunk, int chunks, vector<match_t> &matches, int min_len, long& currentCount, bool print) {$/;"	f	class:sparseSA
findMEM	sparseSA.cpp	/^void sparseSA::findMEM(long k, string &P, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
find_Lmaximal	sparseSA.cpp	/^void sparseSA::find_Lmaximal(string &P, long prefix, long i, long len, vector<match_t> &matches, int min_len, bool print) {$/;"	f	class:sparseSA
forward	mummer.cpp	/^bool forward = true;$/;"	v
from_set	sparseSA.hpp	/^  void from_set(long hit, long &seq, long &seqpos) {$/;"	f	struct:sparseSA
h	qsufsort.c	/^   h;                           \/* length of already-sorted prefixes.*\/$/;"	v	file:
hasChild	sparseSA.hpp	/^  bool hasChild;$/;"	m	struct:sparseSA
hasSufLink	sparseSA.hpp	/^  bool hasSufLink;$/;"	m	struct:sparseSA
idx	sparseSA.hpp	/^    size_t idx; int val;$/;"	m	struct:vec_uchar::item_t
init	sparseSA.hpp	/^  void init() { sort(M.begin(), M.end()); cerr << "M.size()=" << M.size() << endl; }$/;"	f	struct:vec_uchar
interval_t	sparseSA.hpp	/^  interval_t() { start = 1; end = 0; depth = -1; }$/;"	f	struct:interval_t
interval_t	sparseSA.hpp	/^  interval_t(long s, long e, long d) { start = s; end = e; depth = d; }$/;"	f	struct:interval_t
interval_t	sparseSA.hpp	/^struct interval_t {$/;"	s
is_leftmaximal	sparseSA.cpp	/^bool sparseSA::is_leftmaximal(string &P, long p1, long p2) {$/;"	f	class:sparseSA
item_t	sparseSA.hpp	/^    item_t(size_t i, int v) { idx = i; val = v; }$/;"	f	struct:vec_uchar::item_t
item_t	sparseSA.hpp	/^  struct item_t{$/;"	s	struct:vec_uchar
lcp	toci.cpp	/^static long lcp(sauchar_t *start1,sauchar_t *start2,sauchar_t *end)$/;"	f	file:
len	sparseSA.hpp	/^  long len; \/\/ length of match$/;"	m	struct:match_t
length	genDNA.py	/^length = sys.argv[1] * 1000000$/;"	v
load_fasta	fasta.cpp	/^void load_fasta(string filename, string &S, vector<string> &descr, vector<long> &startpos) {$/;"	f
logN	sparseSA.hpp	/^  long logN; \/\/ ceil(log(N)) $/;"	m	struct:sparseSA
main	mummer.cpp	/^int main(int argc, char* argv[]) {$/;"	f
main	toci.cpp	/^int main(int argc, char *argv[])$/;"	f
match_t	sparseSA.hpp	/^  match_t() { ref = 0; query = 0, len = 0; }$/;"	f	struct:match_t
match_t	sparseSA.hpp	/^  match_t(long r, long q, long l) { ref = r; query = q; len = l; }$/;"	f	struct:match_t
match_t	sparseSA.hpp	/^struct match_t {$/;"	s
maxdescrlen	sparseSA.hpp	/^  long maxdescrlen; \/\/ Maximum length of the sequence description, used for formatting.$/;"	m	struct:sparseSA
memCount	sparseSA.cpp	/^long memCount = 0;$/;"	v
min_len	mummer.cpp	/^int min_len = 20;$/;"	v
min_len	sparseSA.cpp	/^  int min_len; \/\/ Minimum length of match.$/;"	m	struct:thread_data	file:
mum_t	mummer.cpp	/^enum mum_t { MUM, MAM, MEM };$/;"	g	file:
nucleotides_only	mummer.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
num_threads	mummer.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
operator ()	sparseSA.cpp	/^struct by_ref { bool operator() (const match_t &a, const match_t &b) const { if(a.ref == b.ref) return a.len > b.len; else return a.ref < b.ref; }  };$/;"	f	struct:by_ref
operator <	sparseSA.hpp	/^    bool operator < (item_t t) const { return idx < t.idx;  }$/;"	f	struct:vec_uchar::item_t
operator []	sparseSA.hpp	/^ int operator[] (size_t idx) {$/;"	f	struct:vec_uchar
printSubstring	mummer.cpp	/^bool printSubstring = false;$/;"	v
printSubstring	sparseSA.hpp	/^  bool printSubstring;$/;"	m	struct:sparseSA
print_length	mummer.cpp	/^bool print_length = false;$/;"	v
print_match	sparseSA.cpp	/^void sparseSA::print_match(match_t m) {$/;"	f	class:sparseSA
print_match	sparseSA.cpp	/^void sparseSA::print_match(match_t m_new, vector<match_t> &buf) {$/;"	f	class:sparseSA
print_match	sparseSA.cpp	/^void sparseSA::print_match(string meta, vector<match_t> &buf, bool rc) {$/;"	f	class:sparseSA
query	sparseSA.hpp	/^  long query; \/\/ position in query$/;"	m	struct:match_t
query_arg	mummer.cpp	/^struct query_arg {$/;"	s	file:
query_fasta	mummer.cpp	/^string query_fasta;$/;"	v
query_thread	mummer.cpp	/^void *query_thread(void *arg_) {$/;"	f
query_threads	mummer.cpp	/^int K = 1, num_threads = 1, query_threads = 1;$/;"	v
r	qsufsort.c	/^   r,                           \/* number of symbols aggregated by transform.*\/$/;"	v	file:
radixStep	sparseSA.cpp	/^void sparseSA::radixStep(int *t_new, int *SA, long &bucketNr, long *BucketBegin, long l, long r, long h) {$/;"	f	class:sparseSA
randint	genDNA.py	/^from random import randint$/;"	i
ref	sparseSA.hpp	/^  long ref; \/\/ position in reference sequence$/;"	m	struct:match_t
reset	sparseSA.hpp	/^  void reset(long e) { start = 0; end = e; depth = 0; }$/;"	f	struct:interval_t
resize	sparseSA.hpp	/^  void resize(size_t N) { vec.resize(N); }$/;"	f	struct:vec_uchar
rev_comp	mummer.cpp	/^bool rev_comp = false, _4column = false, nucleotides_only = false;$/;"	v
reverse_complement	fasta.cpp	/^void reverse_complement(string &seq_rc, bool nucleotides_only) {$/;"	f
sa	mummer.cpp	/^sparseSA *sa;$/;"	v
sa	sparseSA.cpp	/^  sparseSA *sa; \/\/ Suffix array + aux informaton$/;"	m	struct:thread_data	file:
search	sparseSA.cpp	/^bool sparseSA::search(string &P, long &start, long &end) {$/;"	f	class:sparseSA
select_sort_split	qsufsort.c	/^static void select_sort_split(int *p, int n) {$/;"	f	file:
seq	genDNA.py	/^seq = []$/;"	v
set	sparseSA.hpp	/^  void set(size_t idx, int v) {$/;"	f	struct:vec_uchar
setBoth	mummer.cpp	/^bool setBoth = false;$/;"	v
setRevComp	mummer.cpp	/^bool setRevComp = false;$/;"	v
size	sparseSA.hpp	/^  long size() { return end - start + 1; }$/;"	f	struct:interval_t
skip	mummer.cpp	/^  int skip;$/;"	m	struct:query_arg	file:
skip0	mummer.cpp	/^  int skip0;$/;"	m	struct:query_arg	file:
sort_split	qsufsort.c	/^static void sort_split(int *p, int n)$/;"	f	file:
sparseMult	mummer.cpp	/^int sparseMult=1;$/;"	v
sparseMult	sparseSA.hpp	/^  int sparseMult;$/;"	m	struct:sparseSA
sparseSA	sparseSA.cpp	/^sparseSA::sparseSA(string &S_, vector<string> &descr_, vector<long> &startpos_, bool __4column, long K_, bool suflink_, bool child_, int sparseMult_, bool printSubstring_) : $/;"	f	class:sparseSA
sparseSA	sparseSA.hpp	/^struct sparseSA {$/;"	s
start	sparseSA.hpp	/^  long depth, start, end;$/;"	m	struct:interval_t
startpos	sparseSA.hpp	/^  vector<long> &startpos; \/\/ Lengths of concatenated sequences.$/;"	m	struct:sparseSA
suffixlink	sparseSA.cpp	/^bool sparseSA::suffixlink(interval_t &m) {$/;"	f	class:sparseSA
suffixsort	qsufsort.c	/^void suffixsort(int *x, int *p, int n, int k, int l)$/;"	f
suflink	mummer.cpp	/^bool suflink = true;$/;"	v
sys	genDNA.py	/^import sys$/;"	i
thread_data	sparseSA.cpp	/^struct thread_data {$/;"	s	file:
top_down	sparseSA.cpp	/^bool sparseSA::top_down(char c, long i, long &start, long &end) {$/;"	f	class:sparseSA
top_down_child	sparseSA.cpp	/^bool sparseSA::top_down_child(char c, interval_t &cur){$/;"	f	class:sparseSA
top_down_faster	sparseSA.cpp	/^bool sparseSA::top_down_faster(char c, long i, long &start, long &end) {$/;"	f	class:sparseSA
transform	qsufsort.c	/^static int transform(int *x, int *p, int n, int k, int l, int q)$/;"	f	file:
traverse	sparseSA.cpp	/^void sparseSA::traverse(string &P, long prefix, interval_t &cur, int min_len) {$/;"	f	class:sparseSA
traverse_faster	sparseSA.cpp	/^void sparseSA::traverse_faster(const string &P,const long prefix, interval_t &cur, int min_len){$/;"	f	class:sparseSA
trim	fasta.cpp	/^void trim(string &line, long &start, long &end) {$/;"	f
type	mummer.cpp	/^mum_t type = MAM;$/;"	v
update_group	qsufsort.c	/^static void update_group(int *pl, int *pm)$/;"	f	file:
usage	mummer.cpp	/^void usage(string prog) {$/;"	f
val	sparseSA.hpp	/^    size_t idx; int val;$/;"	m	struct:vec_uchar::item_t
vec	sparseSA.hpp	/^  vector<unsigned char> vec;  \/\/ LCP values from 0-65534$/;"	m	struct:vec_uchar
vec_uchar	sparseSA.hpp	/^struct vec_uchar {$/;"	s
write_lock	mummer.cpp	/^void write_lock(int i){$/;"	f
