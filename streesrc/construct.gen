/*
  Copyright (c) 2003 by Stefan Kurtz and The Institute for
  Genomic Research.  This is OSI Certified Open Source Software.
  Please see the file LICENSE for licensing information and
  the file ACKNOWLEDGEMENTS for names of contributors to the
  code base.
*/

CONSTRUCT
{
  DECLAREEXTRA;

  CHECKTEXTLEN;

  DEBUGCODE(3,showvalues());

  initSuffixtree(stree,text,textlen);
  fprintf(stderr, "initSuffixtree se ha ejecutado\n");
  while(stree->tailptr < stree->sentinel || 
        stree->headnodedepth != 0 || stree->headend != NULL)
  {
    CHECKSTEP;
    // case (1): headloc is root
    if(stree->headnodedepth == 0 && stree->headend == NULL) 
    {
      //fprintf(stderr, "case (1): headloc is root construct.gen\nstree->headnodedepth=%x\n",stree->headnodedepth);
      (stree->tailptr)++;
      scanprefix(stree);
    } else
    {
      if(stree->headend == NULL)  // case (2.1): headloc is a node
      {
        //fprintf(stderr, "case (2.1): headloc is a node construct.gen\n");
        FOLLOWSUFFIXLINK;
        scanprefix(stree);
      } else               // case (2.2)
      {
        if(stree->headnodedepth == 0) // case (2.2.1): at root: do not use links
        {
          //fprintf(stderr, "case (2.2.1): at root: do not use links contruct.gen\n");
          if(stree->headstart == stree->headend)  // rescan not necessary
          {
            //fprintf(stderr, "rescan not necessary\n");
            stree->headend = NULL;
          } else
          {
            (stree->headstart)++;
            rescan(stree);
          }
        } else
        {
          FOLLOWSUFFIXLINK;    // case (2.2.2)
          //fprintf(stderr, "case (2.2.2) construct.gen\n");
          rescan(stree);
        }
        if(stree->headend == NULL)  // case (2.2.3): headloc is a node
        {
          //fprintf(stderr, "case (2.2.3) headloc is a node construct.gen\n");
          SETSUFFIXLINK(BRADDR2NUM(stree,stree->headnode));
          COMPLETELARGEFIRST;
          scanprefix(stree);
        } else
        {
          if(stree->smallnotcompleted == MAXDISTANCE)  // artifical large node
          {
            //fprintf(stderr, "ariticial large node construct.gen\n");
            //fprintf(stderr, stree->artificial++);
            //fprintf(stderr,"#artifical large node %lu\n",
            //          (Showuint) stree->nextfreebranchnum);
            SETSUFFIXLINK(stree->nextfreebranchnum + LARGEINTS);
            COMPLETELARGESECOND;
          } else
          { 
            if(stree->chainstart == NULL)
            {
              stree->chainstart = stree->nextfreebranch;   // start new chain
              //fprintf(stderr, "start new chain construc.gen\n");
            } 
            (stree->smallnotcompleted)++;
            (stree->nextfreebranch) += SMALLINTS;      // case (2.2.4)
            //fprintf(stderr, "case (2.2.4) construct.gen\n");
            (stree->nextfreebranchnum) += SMALLINTS;
            stree->smallnode++;
          }
        }
      } 
    }

    PROCESSHEAD;

    if(stree->headend == NULL)
    {
      insertleaf(stree);  // case (a)
    } else
    {
      insertbranchnode(stree);  // case (b)
    }
    DEBUGCODE(5,showtable(stree,False));
  }
  stree->chainstart = NULL;
  linkrootchildren(stree);

//\Ignore{

  fprintf(stderr,"#integers for branchnodes %lu\n",
           (Showuint) stree->nextfreebranchnum);
  fprintf(stderr,"#small %lu large %lu textlen %lu all %lu ",
            (Showuint) stree->smallnode,(Showuint) stree->largenode,
            (Showuint) stree->textlen,
            (Showuint) (stree->smallnode+stree->largenode));
  fprintf(stderr,"ratio %f\n",
         (double) (stree->smallnode+stree->largenode)/stree->nextfreeleafnum);
  fprintf(stderr,"#splitleafedge = %lu\n",(Showuint) stree->splitleafedge);
  fprintf(stderr,"#splitinternaledge = %lu\n",(Showuint) stree->splitinternaledge);
  fprintf(stderr,"#insertleafcalls = %lu\n",(Showuint) stree->insertleafcalls);
  fprintf(stderr,"#artificial = %lu\n",(Showuint) stree->artificial);
  fprintf(stderr,"#multiplications = %lu\n",(Showuint) stree->multiplications);
  showtable(stree,False);
  //showstree(stree);
#ifdef DEBUG
  {
    DEBUG3(2,"#largelinks %lu largelinklinkwork %lu largelinkwork %lu ",
              (Showuint) stree->largelinks,
              (Showuint) stree->largelinklinkwork,
              (Showuint) stree->largelinkwork);
    DEBUG2(2,"#ratio1 %.4f ratio2 %.4f\n",
              (double) stree->largelinkwork/stree->largelinks,
              (double) stree->largelinkwork/stree->textlen);
  }
#endif
  DEBUG2(2,"#%6lu %6lu\n",(Showuint) stree->smallnode,
                          (Showuint) stree->largenode);
  DEBUGCODE(2,showspace());
  DEBUGCODE(1,checkstree(stree));

//}
  FINALPROGRESS;
  return 0;
}
